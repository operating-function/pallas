#### lib_http <- prelude

:| prelude

;;; Bar helpers ;; TODO move these?

;; Like barSubstringLines, but allows splitting on arbitrary characters.
> Bar > Bar > List Bar
= (barSubstringLinesList seek bar)
@ indices (barSubstringSearch seek bar)
@ seekLen (barLen seek)
@ wid (barLen bar)
| listFilter (compose not barIsEmpty)
^ _ 0 indices
? (go start idxList)
: idx rest < listCase idxList
           | listSing (barSlice start (sub wid start) bar)
| CONS (barSlice start (sub idx start) bar)
| go (add idx seekLen) rest

(barSubstringLines seek bar)=(listToRow | barSubstringLinesList seek bar)

=?= ~[x#de x#ad x#20be x#ef]
  | barSubstringLinesList x#0d x#{de0dad0d20be0def0d0d}

=?= [x#de x#ad x#20be x#ef]
  | barSubstringLines x#0d x#{de0dad0d20be0def0d0d}

=?= ~[x#de x#ad x#20be x#ee x#ef]
  | barSubstringLinesList x#0d x#{de0dad0d20be0dee0def}

=?= ~[x#de x#ad x#20be x#ef]
  | barSubstringLinesList x#0d x#{0d0dde0dad0d20be0def0d}

=?= ~[x#de x#ad x#200dbe x#ef]
  | barSubstringLinesList x#0d0a0d x#{de0d0a0dad0d0a0d200dbe0d0a0def0d0a0d}


> Bar > Bar > Maybe (Bar, Bar)
= (barSplitOnSubstring substr bar)
: idx _ < listCase | barSubstringSearch substr bar
        | NONE
| SOME (barTake idx bar, barDrop (add idx (barLen substr)) bar)


=?= SOME-[b#foo b#baz]   | barSplitOnSubstring b#bar b#foobarbaz
=?= SOME-[b#{} b#barbaz] | barSplitOnSubstring b#foo b#foobarbaz
=?= SOME-[b#foobar b#{}] | barSplitOnSubstring b#baz b#foobarbaz
=?= NONE                 | barSplitOnSubstring b#{ } b#foobarbaz


= CRLF        | x#0d0a
= DOUBLE_CRLF | x#0d0a0d0a


;;; HTTP types

# datatype Method
* GET=GET
* POST=POST


# record HTTPRequest
| HTTP_REQ
* reqMethod  : Method          ; HTTP method
* reqPath    : Bar             ; Request URI
* reqVersion : Bar             ; HTTP version
* reqHeader  : Tab Bar Bar     ; Request headers
* reqBody    : Pin Bar         ; Request body; may be empty

# record HTTPResponse
| HTTP_RES
* version      : Bar             ; HTTP version
* statusCode   : Nat             ; Numeric status code (for automata)
* reasonPhrase : Bar             ; e.g "OK", "Not Found" (for humans)
* resHeaderL   : Tab Bar Bar     ; Response headers
* resBody      : Bar             ; Response body ;; TODO pin this?


> HTTPResponse > Bar
= (httpResToBar httpRes)
@ v     | getVersion      httpRes
@ c     | getStatusCode   httpRes
@ s     | getReasonPhrase httpRes
@ h     | getResHeaderL   httpRes
@ b     | getResBody      httpRes
@ statusLine         | barCat [v x#20 (natBar | showNat c) x#20 s]
@ headersSeparated   | barIntercalateList CRLF h
@ printBodySeparator | if (barIsEmpty b) b#{} DOUBLE_CRLF
| barCat
++ statusLine
++ CRLF
++ headersSeparated
++ printBodySeparator
++ b


= (error400 msg)
@ headers | tabIns b#{Content-Length} 0
          | tabSing b#{Server} b#{Pallas/0.1}
@ headersList | tabValsList
              | tabMapWithKey (k v & (barCat [k b#{: } v]))
              | headers
| HTTP_RES
;; TODO: move these things to "constants"
* b#{HTTP/1.0}
* 400
* msg
* headersList
* NIL


= (error500 msg)
@ headers | tabIns b#{Content-Length} 0
          | tabSing b#{Server} b#{Pallas/0.1}
@ headersList | tabValsList
              | tabMapWithKey (k v & (barCat [k b#{: } v]))
              | headers
| HTTP_RES
;; TODO: move these things to "constants"
* b#{HTTP/1.0}
* 500
* msg
* headersList
* NIL


;;; Request parsing

# datatype ParserState
* AWAITING_REQ_LINE
* AWAITING_HEADERS      reqLine:(Method,Bar,Bar)
* AWAITING_BODY len:Nat reqLine:(Method,Bar,Bar) headers:(Tab Bar Bar)
* COMPLETE              reqLine:(Method,Bar,Bar) headers:(Tab Bar Bar) body:Bar
* PARSER_ERROR  err:Bar


# record HTTPParser 
| HTTP_PARSER
* accumulated : Bar
* state       : ParserState


= newHTTPParser
| HTTP_PARSER
* b#{}
* AWAITING_REQ_LINE


> Bar > Maybe (Method, Bar, Bar)
= (parseRequestLine line)
@ parts | listToRow | barSplit { } line
| maybeGuard (len-parts == 3)
@ [method path version] | parts
@ method | barNat method
| maybeGuard (any (eql method) [GET POST]) ;; TODO remove once we have types
; maybeGuard (version == b#{HTTP/1.0}) ;; TODO eeh?
| SOME (method, path, version)


> HTTPParser > ((Method, Bar, Bar) > Bar > HTTPParser) > HTTPParser
= (processReqLine parser step)
# datacase | getState parser
* _ | parser
* AWAITING_REQ_LINE
: (line, rest) < maybeCase | barSplitOnSubstring CRLF | getAccumulated parser
               | parser
: reqLineParts < maybeCase | parseRequestLine line
               | trk [reqLine=line]
               | setState (PARSER_ERROR b#{Invalid request line}) parser
| step reqLineParts rest


> Bar > Tab Bar Bar
= (parseHeaders bar)
^ listFoldl _ emptyTab | barSubstringLinesList CRLF bar
& (headers line)
@ (key,val) | barSplitOne {:} line
@ key | barTrim key
@ val | barTrim val
| if barIsEmpty-key | headers
| tabIns key val headers


> HTTPParser > (Tab Bar Bar > Bar > HTTPParser) > HTTPParser
= (processHeaders parser step)
@ HTTP_PARSER(..) parser
# datacase state
* _ | parser
* AWAITING_HEADERS|_
: (headerBar, rest) < maybeCase | barSplitOnSubstring DOUBLE_CRLF accumulated
                    | parser
@ headers | parseHeaders headerBar
| step headers rest


= (processBody parser step)
@ HTTP_PARSER(..) parser
# datacase state
* _ | parser
* (AWAITING_BODY sz _ _)
| if (gth sz | barLen accumulated) | parser
| uncurry step | barSplitAt sz accumulated


= (stepParser parser)
@ HTTP_PARSER(..) parser
# datacase state
* (COMPLETE _ _ _)   | parser
* (PARSER_ERROR msg) | parser
* AWAITING_REQ_LINE
  : reqLine rest < processReqLine parser
  | stepParser
  | HTTP_PARSER rest | AWAITING_HEADERS reqLine
* (AWAITING_HEADERS reqLine)
  : headers rest < processHeaders parser
  | fromSome | HTTP_PARSER rest | COMPLETE reqLine headers b#{}
  : contentLength < bindMaybe | tabLookup b#{Content-Length} headers
  : sz            < bindMaybe | parseNat contentLength ;; TODO error instead
  | maybeGuardNot | eql sz 0
  ^ SOME | stepParser _
  | HTTP_PARSER rest | AWAITING_BODY sz reqLine headers
* (AWAITING_BODY _ reqLine headers)
  : body rest < processBody parser
  | ifNot (barIsEmpty rest)
    | trk [=rest]
    | setState (PARSER_ERROR b#{body too long}) parser
  | HTTP_PARSER rest | COMPLETE reqLine headers body


> HTTPParser > Bar > HTTPParser
= (feedData parser newData)
@ cum | getAccumulated parser
| stepParser | setAccumulated (barWeld cum newData) parser


> HTTPParser > Maybe (Either Bar HTTPRequest)
= (getResult parser)
# datacase | getState parser
* _                | NONE
* PARSER_ERROR|msg | SOME LEFT-msg
* (COMPLETE (method,path,version) headers body)
^ SOME | RIGHT _
| HTTP_REQ
* method
* path 
* version
* headers
* PIN body
