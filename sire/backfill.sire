#### backfill <- infer

:| sire
:| infer

;; sire_01_fan


#* # abstype  Law
#* # abstype  App
#* # backfill LAW      (Str > Nat > Any > Law)
#* # backfill valCase  ((Any > a) > (Str > Nat > Any > a) > (Any > Any > a) > (Nat > a) > Any > a)
#* # backfill natCase  (a > (Nat > a) > Nat > a)
#* # backfill inc      (Nat > Nat)
#* # backfill PIN      (a > Pin a)
#* # backfill die      (a > b)
#* # backfill todo     (a > b)
#* # backfill force    (a > a) 
#* # backfill seq      (a > b > b)
#* # backfill deepseq  (a > b > b)
#* # backfill trace    (a > b > b)
#* # backfill deepTrace (a > b > b)
#* # backfill traceId  (a > a)
#* # backfill deepTraceId (a > a)
#* # backfill isPin     (Any > Bit)
#* # backfill isLaw     (Any > Bit) 
#* # backfill isApp     (Any > Bit)
#* # backfill isNat     (Any > Bit)
#* # backfill planTag   (Any > Nat)
#* # backfill pinItem   (Pin a > a)
#* # backfill lawName   (Law > Nat)
#* # backfill lawArgs   (Law > Nat)
#* # backfill lawBody   (Law > Any)
#* # backfill car       (App > Any)
#* # backfill cdr       (App > Any)
#* # backfill isZero    (Nat > Bit)

#* # backfill caar      (App > Any)
#* # backfill cadr      (App > Any)
#* # backfill cdar      (App > Any)
#* # backfill cddr      (App > Any)
#* # backfill caaar     (App > Any)
#* # backfill caadr     (App > Any)
#* # backfill cadar     (App > Any)
#* # backfill caddr     (App > Any)
#* # backfill cdaar     (App > Any)
#* # backfill cdadr     (App > Any)
#* # backfill cddar     (App > Any)
#* # backfill cdddr     (App > Any)
#* # backfill caaaar    (App > Any)

#* # backfill id        (a > a)
#* # backfill const     (a > b > a)
#* # backfill ignore    (a > b > b) 
#* # backfill compose   ((b > c) > (a > b) > a > c)
#* # backfill flip      ((a > b > c) > b > a > c)
#* # backfill apply     ((a > b) > a > b)
#* # backfill supply    (a > (a > b) > b)

;; sire_02_bit
#* # backfill TRUE     Bit
#* # backfill FALSE    Bit
#* # backfill if       (Bit > a > a > a)
#* # backfill ifNot    (Bit > a > a > a)
#* # backfill ifz      (Nat > a > a > a)
#* # backfill ifNonZero (Nat > a > a > a)
#* # backfill else     (a > a)
#* # backfill bit      (a > Bit)
#* # backfill not      (Bit > Bit)
#* # backfill and      (Bit > Bit > Bit)
#* # backfill or       (Bit > Bit > Bit)
#* # backfill xor      (Bit > Bit > Bit)
#* # backfill nand     (Bit > Bit > Bit)
#* # backfill nor      (Bit > Bit > Bit)
#* # backfill xnor     (Bit > Bit > Bit)

;; sire_03_nat
#* # backfill isNat    (a > Bit)
#* # backfill toNat    (a > Nat)
#* # backfill times    (a > b > c > d)
#* # backfill inc      (Nat > Nat)
#* # backfill dec      (Nat > Nat)
#* # backfill add      (Nat > Nat > Nat)
#* # backfill sub      (Nat > Nat > Nat)
#* # backfill mod      (Nat > Nat > Nat)
#* # backfill mul      (Nat > Nat > Nat)
#* # backfill div      (Nat > Nat > Nat)
#* # backfill divMod   (Nat > Nat > (Nat, Nat))
#* # backfill lsh      (Nat > Nat > Nat)
#* # backfill rsh      (Nat > Nat > Nat)
#* # backfill con      (Nat > Nat > Nat)
#* # backfill mix      (Nat > Nat > Nat)
#* # backfill dis      (Nat > Nat > Nat)
#* # backfill pow      (Nat > Nat > Nat)
#* # backfill bex      (Nat > Nat)
#* # backfill bix      (Nat > Nat > Bit)
#* # backfill met      (Nat > Nat)
#* # backfill LT       Ordering
#* # backfill EQ       Ordering
#* # backfill GT       Ordering
#* # backfill ordWeld  (Ordering > Ordering > Ordering)
#* # backfill even     (Nat > Bit)
#* # backfill odd      (Nat > Bit)
#* # backfill roundUp  (Nat > Nat > Nat)


;; sire_04_cmp
#* # backfill isZero   (a > Bit)
#* # backfill isOne    (a > Bit)
#* # backfill cmp      (a > a > Ordering)
#* # backfill eql      (a > a > Bit)
#* # backfill neq      (a > a > Bit)
#* # backfill lth      (a > a > Bit)
#* # backfill lte      (a > a > Bit)
#* # backfill gth      (a > a > Bit)
#* # backfill gte      (a > a > Bit)
#* # backfill min      (a > a > a)
#* # backfill max      (a > a > a)

;; sire_05_row
#* # backfill head     (Row a > a)
#* # backfill last     (Row a > a)
#* # backfill null     (Row a > Bit)
#* # backfill arity    (a > Nat)
#* # backfill len      (Row a > Nat)
#* # backfill idx      (Nat > Row a > a)
#* # backfill get      (Row a > Nat > a)
#* # backfill mut      (Nat > a > Row a > Row a)
#* # backfill put      (Row a > Nat > a > Row a)
#* # backfill switch   (Nat > a > Row a > a)
#* # abstype  Cow
#* # backfill cow      (Nat > Cow)
#* # backfill isCow    (a > Bit)
#* # backfill cowSize  (Cow > Nat)
#* # backfill isRow    (a > Bit)
#* # backfill weld     (Row a > Row a > Row a)
#* # backfill gen      (Nat > (Nat > a) > Row a)
#* # backfill foldr    ((a > b > b) > b > Row a > b)
#* # backfill foldl    ((b > a > b) > b > Row a > b)
#* # backfill fst      (Row a > a)
#* # backfill snd      (Row a > a)
#* # backfill thr      (Row a > a)
#* # backfill map      ((a > b) > Row a > Row b)
#* # backfill foreach  (Row a > (a > b) > Row b)
#* # backfill rev      (Row a > Row a)
#* # backfill curry    ((Row (a, b) > c) > a > b > c)
#* # backfill uncurry  ((a > b > c) > Row (a, b) > c)
#* # backfill rowCons  (a > Row a > Row a)
#* # backfill rowSnoc  (Row a > a > Row a)
#* # backfill rowApply ((Row a > b) > Row a > b)
#* # backfill rowRepel ((a > b > c) > Row (a, b) > c)

;; sire_06_rex
;; #* # backfill EMBD      (a > Rex) 
;; #* # backfill WORD      (Str > Heir > Rex)
;; #* # backfill TEXT      (Str > Heir > Rex)
;; #* # backfill LINE      (Str > Heir > Rex)
;; #* # backfill OPEN      (Rune > Sons > Heir > Rex)
;; #* # backfill NEST      (Rune > Sons > Heir > Rex)
;; #* # backfill INFX      (Rune > Sons > Heir > Rex)
;; #* # backfill PREF      (Rune > Sons > Heir > Rex) 
;; #* # backfill SHUT      (Rune > Sons > Heir > Rex)
;; #* # backfill rexIsNode    (Rex > Bit)
;; #* # backfill rexIsLeaf    (Rex > Bit) 
;; #* # backfill rexIsEmbd    (Rex > Bit)
;; #* # backfill rexRune      (Rex > Rune)
;; #* # backfill rexSetRune   (Rune > Rex > Rex)
;; #* # backfill rexHeir      (Rex > Heir)
;; #* # backfill rexSetHeir   (Heir > Rex > Rex)
;; #* # backfill rexStr      (Rex > Str)
;; #* # backfill rexSetStr   (Str > Rex > Rex)
;; #* # backfill rexSons      (Rex > Row Rex)
;; #* # backfill rexSetSons   (Row Rex > Rex > Rex)
;; #* # backfill rexKids      (Rex > Row Rex)
;; #* # backfill rexType      (Rex > Str)
;; #* # backfill rexStyle     (Rex > Str)
;; #* # backfill rexGetEmbd   (Rex > a > (a > b) > b)
;; #* # backfill rexGetLeaf   (Rex > a > ((Str, Heir) > b) > b)
;; #* # backfill rexGetNode   (Rex > a > ((Rune, Sons, Heir) > b) > b)
;; #* # backfill rexEvery     ((Rex > Rex) > Rex > Rex)
;; #* # backfill rexClose     (Rex > Rex)

;; sire_07_dat
#* # backfill slash        (Row a > Nat > Nat > Row a)
#* # backfill slice        (Row a > Nat > Nat > Row a) 
#* # backfill chunks       (Nat > Row a > Row (Row a))
#* # backfill rep          (a > Nat > Row a)
#* # backfill rowCons      (a > Row a > Row a)
#* # backfill rowSnoc      (Row a > a > Row a)
#* # backfill rowAnd       (Row Bit > Bit)
#* # backfill rowOr        (Row Bit > Bit)
#* # backfill sum          (Row Nat > Nat)
#* # backfill sumOf        ((a > Nat) > Row a > Nat)
#* # backfill all          ((a > Bit) > Row a > Bit)
#* # backfill any          ((a > Bit) > Row a > Bit)
#* # backfill cat          (Row (Row a) > Row a)
#* # backfill catMap       ((a > Row b) > Row a > Row b)
#* # backfill unfoldr      ((b > Maybe (Row a, b)) > b > Row a)
#* # backfill span         ((a > Bit) > Row a > (Row a, Row a))
#* # backfill splitAt      (Nat > Row a > (Row a, Row a))
#* # backfill foldr1       ((a > a > a) > Row a > a)
#* # backfill strictRow    (Row a > Row a)
#* # backfill appE         (Row Exp > Exp)
#* # backfill rowE         (Row Exp > Exp)
#* # backfill NONE         (Maybe a)
#* # backfill SOME         (a > Maybe a)
#* # backfill maybeCase    (Maybe a > b > (a > b) > b)
#* # backfill maybe        (b > (a > b) > Maybe a > b)
#* # backfill isSome       (Maybe a > Bit)
#* # backfill isNone       (Maybe a > Bit)
#* # backfill fmapMaybe    (Maybe a > (a > b) > Maybe b)
#* # backfill NIL                  (List a)
#* # backfill CONS                 (a > List a > List a)
#* # backfill listCase            (List a > b > (a > List a > b) > b)
#* # backfill listSing            (a > List a)
#* # backfill listMap             ((a > b) > List a > List b)
#* # backfill listForEach         (List a > (a > b) > List b)
#* # backfill listHead            (List a > Maybe a)
#* # backfill listSafeHead        (a > List a > a)
#* # backfill listUnsafeHead      (List a > a)
#* # backfill listUnsafeTail      (List a > List a)
#* # backfill listIdxCps          (Nat > List a > b > (a > b) > b)
#* # backfill listIdxOr           (a > Nat > List a > a)
#* # backfill listIdx             (Nat > List a > a)
#* # backfill listFoldl           ((b > a > b) > b > List a > b)
#* # backfill listFoldl1          ((a > a > a) > List a > a)
#* # backfill listFoldr           ((a > b > b) > b > List a > b)
#* # backfill listLen             (List a > Nat)
#* # backfill listToRow           (List a > Row a)
#* # backfill listFromRow         (Row a > List a)
#* # backfill listAnd             (List Bit > Bit)
#* # backfill listOr              (List Bit > Bit)
#* # backfill listSum             (List Nat > Nat)
#* # backfill listAll             ((a > Bit) > List a > Bit)
#* # backfill listAny             ((a > Bit) > List a > Bit)
#* # backfill listHas             (a > List a > Bit)
#* # backfill listEnumFrom        (Nat > List Nat)
#* # backfill listWeld            (List a > List a > List a)
#* # backfill listCat             (List (List a) > List a)
#* # backfill listCatMap          ((a > List b) > List a > List b)
#* # backfill listTake            (Nat > List a > List a)
#* # backfill listDrop            (Nat > List a > List a)
#* # backfill listTakeWhile       ((a > Bit) > List a > List a)
#* # backfill listDropWhile       ((a > Bit) > List a > List a)
#* # backfill listFilter          ((a > Bit) > List a > List a)
#* # backfill listIsEmpty         (List a > Bit)
#* # backfill listMinimumOn       ((a > b) > a > List a > a)
#* # backfill listSortOn          ((a > b) > List a > List a)
#* # backfill listNub             (List a > List a)
#* # backfill listIterate         ((a > a) > a > List a)
#* # backfill listGen             (Nat > (Nat > a) > List a)
#* # backfill listRep             (a > Nat > List a)
#* # backfill listFindIndex       ((a > Bit) > List a > b > (Nat > b) > b)
#* # backfill listElemIndex       (a > List a > b > (Nat > b) > b)
#* # backfill LEFT                (a > Either a b)
#* # backfill RIGHT               (b > Either a b)
#* # backfill fromLeft            (b > Either a b > a)
#* # backfill unpackLeft          (Either a b > a)
#* # backfill fromRight           (a > Either a b > b)
#* # backfill unpackRight         (Either a b > b)
#* # backfill eitherCase          (Either a b > (a > c) > (b > c) > c)
#* # backfill eitherOpen          (Either a b > (b > c) > c)
#* # backfill eitherMap           ((b > c) > Either a b > Either a c)
#* # backfill eitherBind          (Either a b > (b > Either a c) > Either a c)
#* # backfill partition           (Row (Either a b) > (Row a, Row b))
#* # backfill sort                (Row a > Row a)
#* # backfill sortBy              ((a > a > Ordering) > Row a > Row a)
#* # backfill sortOn              ((a > b) > Row a > Row a)
#* # backfill sortUniq            (Row a > Row a)
#* # backfill filter              ((a > Bit) > Row a > Row a)
#* # backfill delete              (a > Row a > Row a)
#* # backfill findIdxMany         ((a > Bit) > Row a > List Nat)
#* # backfill elemIdxMany         (a > Row a > List Nat)
#* # backfill lsearch             (a > Row a > Nat)
#* # backfill bsearch             (a > Row a > Nat)
;; #* # backfill traverseList        ((a > (b > r)) > List a > m (List b))
;; #* # backfill listTraverseState   (st > (a > (st > b > r)) > List a > m st (List b))
;; #* # backfill rowTraverse         ((a > (b > r)) > Row a > m (Row b))
;; #* # backfill rowTraverseState    (st > (a > (st > b > r)) > Row a > m st (Row b))

;; sire_10_str 
#* # backfill ord          (Char > Nat)
#* # backfill chr          (Nat > Char)
#* # backfill isDigit      (Char > Bit)
#* # backfill isHexDigit   (Char > Bit)
#* # backfill isUpper      (Char > Bit)
#* # backfill isLower      (Char > Bit)
#* # backfill isAlpha      (Char > Bit)
#* # backfill isPrint      (Char > Bit)
#* # backfill isAlphaNum   (Char > Bit)
#* # backfill toLower      (Char > Char)
#* # backfill toUpper      (Char > Char)
#* # backfill strLen       (Str > Nat)
#* # backfill strWeld      (Str > Str > Str)
#* # backfill strCat       (Row Str > Str)
#* # backfill strMap       ((Char > Char) > Str > Str)
#* # backfill explode      (Str > Row Char)
#* # backfill implode      (Row Char > Str)
#* # backfill isDecimalLit (Str > Bit)
#* # backfill loadDecimal  (Str > Nat)
#* # backfill isHexLit     (Str > Bit)
#* # backfill loadHexLit   (Str > Nat)
#* # backfill loadKeyWord  (Str > Nat)

;; sire_11_set
#* # backfill isSet        (a > Bit)
#* # backfill emptySet     (Set a)
#* # backfill setIsEmpty   (Set a > Bit)
#* # backfill setSing      (a > Set a)
#* # backfill setFromRow   (Row a > Set a)
#* # backfill setFromRowAsc (Row a > Set a)
#* # backfill setToRow     (Set a > Row a)
#* # backfill setLen       (Set a > Nat)
#* # backfill setToList    (Set a > List a)
#* # backfill setFoldl     ((b > a > b) > b > Set a > b)
#* # backfill setFoldr     ((a > b > b) > b > Set a > b)
#* # backfill setIns       (a > Set a > Set a)
#* # backfill setDel       (a > Set a > Set a)
#* # backfill setHas       (a > Set a > Bit)
#* # backfill setWeld      (Set a > Set a > Set a)
#* # backfill setCatRow    (Row (Set a) > Set a)
#* # backfill setCatList   (List (Set a) > Set a)
#* # backfill setMin       (Set a > a)
#* # backfill setMax       (Set a > a)
#* # backfill setPop       (Set a > (a, Set a))
#* # backfill setIntersect (Set a > Set a > Set a)

;; sire_12_tab
#* # backfill tabSing      (k > v > Tab k v)
#* # backfill isTab        (a > Bit)
#* # backfill tabLen       (Tab k v > Nat)
#* # backfill tabIdx       (k > Tab k v > v)
#* # backfill tabKeysSet   (Tab k v > Set k)
#* # backfill tabGet       (Tab k v > k > v)
#* # backfill tabHas       (k > Tab k v > Bit)
#* # backfill tabIns       (k > v > Tab k v > Tab k v)
#* # backfill tabDel       (k > Tab k v > Tab k v) 
#* # backfill tabPop       (Tab k v > (k, v, Tab k v))
#* # backfill tabMap       ((a > b) > Tab k a > Tab k b)
#* # backfill tabWeld      (Tab k v > Tab k v > Tab k v)
#* # backfill tabCatRow    (Row (Tab k v) > Tab k v)
#* # backfill emptyTab     (Tab k v)
;; #* # backfill tabE         (Tab Exp > Exp)

;; sire_13_exp
;; #* # backfill readNodeWithRune        (Rune > Rex > a > ((Row Rex, Heir) > b) > b)  
;; #* # backfill readKidsOfNodeWithRune  (Rune > Rex > a > (Row Rex > b) > b)
;; #* # backfill readNodeWithoutHeirButWithRune (Rune > Rex > a > (Row Rex > b) > b)
;; #* # backfill isSymbolChar           (Char > Bit)
;; #* # backfill strIsSymbol            (Str > Bit) 
;; #* # backfill rexIsSymbol            (Rex > Bit)
;; #* # backfill readSymbol             (Rex > a > (Str > b) > b)
;; #* # backfill natE                   (Nat > Rex)
;; #* # backfill litE                   (a > Rex)
;; #* # backfill varE                   (Str > Rex)
;; #* # backfill cnsE                   (a > Rex)
;; #* # backfill barE                   (Row Rex > Rex)
;; #* # backfill letE                   (Str > Rex > Rex > Rex)
;; #* # backfill recE                   (Row (Str, Rex) > Rex > Rex)
;; #* # backfill sigE                   (Row Str > Rex)
;; #* # backfill lamE                   (Row Str > Rex > Rex)
;; #* # backfill wutE                   (Bit > Bit > Str > Row Str > Rex > Rex)
;; #* # backfill inlinedLamE            (Str > Row Str > Rex > Rex)
;; #* # backfill bloodline              (List Rex > Rex)
;; #* # backfill showNat                (Nat > Str)
;; #* # backfill getNatStr              (Str > a > (Nat > b) > b)
;; #* # backfill readNat                (Rex > a > (Nat > b) > b)
;; #* # backfill showDigit              (Nat > Char)
;; #* # backfill loadDigit              (Char > Nat)
;; #* # backfill getDigit               (Char > a > (Nat > b) > b)
;; #* # backfill readAtomLit            (Rex > a > (b > c) > c)
;; #* # backfill readRowOfNames         (Rex > a > (Row Str > b) > b)
;; #* # backfill rexParseKids           (Rex > Row (a > b) > c > ((Row d) > e) > e)
;; #* # backfill rexParseSons           (Rex > Row (a > b) > c > (d > e) > e)
;; #* # backfill tmpName                (Str > Nat > Str)
;; #* # backfill tmpVarE                (Str > Nat > Rex)
;; #* # backfill generateUniqueKey      (st > ((st, Nat) > b) > b)
;; #* # backfill generateTempName       (Str > st > ((st, Str) > b) > b)
;; #* # backfill generateVarE           (Str > st > ((st, Rex) > b) > b)
;; #* # backfill generateTempAnon       (st > ((st, Str) > b) > b)
;; #* # backfill generateAnonVarE       (st > ((st, Rex) > b) > b)

;; sire_14_hax 
;; #* # backfill {#}                    (Rune)
;; #* # backfill {#quote}               (Rune)
;; #* # backfill {#getenv}              (Rune)

;; sire_15_pad
#* # backfill emptyPad               (Pad)
#* # backfill toPad                  (a > Pad)
#* # backfill padNat                 (Pad > Nat)
#* # backfill natPad                 (Nat > Nat > Pad)
#* # backfill padLen                 (Pad > Nat)
#* # backfill padWeld                (Pad > Pad > Pad)
#* # backfill padCat                 (Row Pad > Pad)
#* # backfill padFlat                (a > Pad)
#* # backfill padSplitAt             (Nat > Pad > (Pad, Pad))
#* # backfill padIdx                 (Nat > Pad > Bit)
#* # backfill padGet                 (Pad > Nat > Bit)
#* # backfill padSet                 (Pad > Nat > Bit > Pad)
#* # backfill padMapWithKey          ((Nat > Bit > Bit) > Pad > Pad)
#* # backfill padMap                 ((Bit > Bit) > Pad > Pad)
#* # backfill padComplement          (Pad > Pad)
#* # backfill readPadStr             (Rex > Str > a > (Pad > b) > b)
#* # backfill showPadStr             (Pad > Str)
#* # backfill readPadLit             (Rex > a > (Pad > b) > b)
#* # backfill showPadLit             (Pad > Rex)
;; #* # backfill {#p}                   (Rune)

;; sire_16_bar
#* # backfill isBar                  (a > Bit)
#* # backfill padBar                 (Pad > Bar)
#* # backfill emptyBar               (Bar)
#* # backfill barIsEmpty             (Bar > Bit)
#* # backfill byteWidth              (Nat > Nat)
#* # backfill barTrail               (Nat > Nat)
#* # backfill barEnc                 (Nat > Nat > Nat)
#* # backfill barDec                 (Nat > Nat)
#* # backfill mkBar                  (Nat > Nat > Bar)
#* # backfill natBar                 (Nat > Bar)
#* # backfill barNat                 (Bar > Nat)
#* # backfill barLen                 (Bar > Nat)
#* # backfill barIdx                 (Nat > Bar > Word8)
#* # backfill natToSizedBar          (Nat > Nat > Bar)
#* # backfill barSing                (Nat > Bar)
#* # backfill barDuo                 (Nat > Nat > Bar)
#* # backfill zEnd                   (Row a > Nat)
#* # backfill stripZEnd              (Row a > Row a)
#* # backfill w8                     (Nat > Word8)
#* # backfill bytesBar               (Row Word8 > Bar)
#* # backfill barGen                 (Nat > (Nat > Word8) > Bar)
#* # backfill barRep                 (Nat > Word8 > Bar)
#* # backfill barGet                 (Bar > Nat > Word8)
#* # backfill barBytes               (Bar > Row Word8)
#* # backfill barWeld                (Bar > Bar > Bar)
#* # backfill barCat                 (Row Bar > Bar)
#* # backfill barCatList             (List Bar > Bar)
#* # backfill barTake                (Nat > Bar > Bar)
#* # backfill barDrop                (Nat > Bar > Bar)
#* # backfill barSlice               (Nat > Nat > Bar > Bar)
#* # backfill barSliceToNat          (Nat > Nat > Bar > Nat)
#* # backfill barFoldl               ((a > Word8 > a) > a > Bar > a)
#* # backfill barFoldr               ((Word8 > a > a) > a > Bar > a)
#* # backfill barAny                 ((Word8 > Bit) > Bar > Bit)
#* # backfill barAll                 ((Word8 > Bit) > Bar > Bit)
#* # backfill barFromHex             (Str > Bar)
#* # backfill barPad                 (Bar > Pad)
#* # backfill barTreeToList          (a > List Bar)
#* # backfill barFlat                (a > Bar)
#* # backfill barHas                 (Word8 > Bar > Bit)
#* # backfill barToRow               (Bar > Row Word8)
#* # backfill barFromRow             (Row Word8 > Bar)
#* # backfill barFromList            (List Word8 > Bar)
#* # backfill barFromListRev         (List Word8 > Bar)
#* # backfill barMap                 ((Word8 > Word8) > Bar > Bar)
#* # backfill barFilter              ((Word8 > Bit) > Bar > Bar)
#* # backfill barFindIndex           ((Word8 > Bit) > Bar > Nat)
#* # backfill barElemIndex           (Word8 > Bar > Nat)
#* # backfill barElemIndexEnd        (Word8 > Bar > Maybe Nat)
#* # backfill barSplitAt             (Nat > Bar > (Bar, Bar))
#* # backfill barSplitOne            (Word8 > Bar > (Bar, Bar))
#* # backfill barSplit               (Word8 > Bar > List Bar)
#* # backfill getHexBar              (Bar > a > (Nat > b) > b)
#* # backfill barLoadDecimal         (Bar > Nat)
#* # backfill barShowDecimal         (Nat > Bar)
#* # backfill readBarLit             (Rex > a > (Bar > b) > b)
#* # backfill showBarLit             (Bar > Rex)
;; #* # backfill {#b}                   (Rune)
;; #* # backfill {#x}                   (Rune)

;; sire_17_sug
;; #* # backfill rexGetRune             (Rex > a > (Rune > b) > b)
;; #* # backfill readSignature          (Rex > a > (Row Str > b) > b)
;; #* # backfill readItemized           (Rune > (Rex > a > b > b) > (Rex > a > b > b) > Rex > a > ((List c) > d) > d)
;; #* # backfill readFancyApp           ((Rex > a > b > b) > Rex > a > (Row Rex > c) > c)
;; #* # backfill readTallListLit        ((Rex > a > b > b) > Rex > a > (List Rex > c) > c)
;; #* # backfill readWideListLit        ((Rex > a > b > b) > Rex > a > (List Rex > c) > c)
;; #* # backfill readNotEqlExp          ((Rex > a > b > b) > Rex > a > (c > d > e) > e)
;; #* # backfill readQuasiQuotedRex     ((Rex > a > b > b) > (Rex > a > c > c) > Rex > a > (Rex > d) > d)
;; #* # backfill splicedE               (Rex > Rex)
;; #* # backfill binTreeFold            ((a > a > a) > Row a > a)
;; #* # backfill readInfixRight         ((Rex > a > b > b) > Rune > Rex > a > (Row Rex > c) > c)
;; #* # backfill readInfixLeft          ((Rex > a > b > b) > Rune > Rex > a > (Row Rex > c) > c)
;; #* # backfill readEqlExp             ((Rex > a > b > b) > Rex > a > (Row Rex > c) > c)
;; #* # backfill multiEqlE              (Nat > Row Rex > (Nat, Rex))
;; #* # backfill readColExp             ((Rex > a > b > b) > (Rex > a > c > c) > Rex > a > (Rex > Maybe Str > Row Rex > Rex > d) > d)
;; #* # backfill colExpE                (Rex > Maybe Str > Row Rex > Rex > Rex)
;; #* # backfill {|}                    (Rune)
;; #* # backfill {:}                    (Rune)
;; #* # backfill {~}                    (Rune)
;; #* # backfill {~~}                   (Rune) 
;; #* # backfill {:}                    (Rune)
;; #* # backfill {`}                    (Rune)
;; #* # backfill {&&}                   (Rune)
;; #* # backfill {||}                   (Rune)
;; #* # backfill {==}                   (Rune)
;; #* # backfill {/=}                   (Rune)
;; #* # backfill {!!}                   (Rune)

;; sire_18_pat
#* # abstype  (Parser a)
#* # abstype  (Parser3 a b c)
#* # backfill readBindSig           (Rex > Parser (Row Pat)) 
#* # backfill parseBinder           (Rex > Parser Pat)
;; #* # backfill readDestroyer         (Rex > Parser3 Bit Key (Row Pat))
#* # backfill makeDestroyer         (SireState > Row Pat > Rex > (SireState > Rex) > (SireState > Row Str > Rex))
#* # backfill sequenceBinds         (SireState > Row (Pat, Rex) > (SireState, Row (Nat, Str, Rex), Row Str)) 
#* # backfill bindSeqE              (Row (Nat, Str, Rex) > Rex > Row Str > Rex)
#* # backfill destructureRowE       (Nat > Row Str > Rex > Rex > Rex)
#* # backfill destructureTabE       (Nat > Tab Str Str > Rex > Rex > (Nat > Rex) > (Nat, Rex))
;; #* # backfill readLet               ((Rex > Read e) > Rex > Parser2 (Row (SugaredBinder e)) e)
#* # backfill mkDefsC              (SireState > List (Nat,Pat,Rex) > (SireState,Rex))
;; #* # backfill {@}                   (Rune)
;; #* # backfill {?}                   (Rune) 
;; #* # backfill {??}                  (Rune)
;; #* # backfill {&}                   (Rune)
;; #* # backfill {=}                   (Rune)
;; #* # backfill {:}                   (Rune)

;; sire_19_bst
#* # abstype  (BST k v)
#* # backfill bst                   (Row (k,v) > BST k v)
#* # backfill bstAlter             (k > (Maybe v > Maybe v) > BST k v > BST k v)
#* # backfill bstDel               (k > BST k v > BST k v)
#* # backfill bstEmpty             (BST k v) 
#* # backfill bstFilterWithKey     ((k > v > Bit) > BST k v > BST k v)
#* # backfill bstFromPairsList     (List (k,v) > BST k v)
#* # backfill bstHas               (k > BST k v > Bit)
#* # backfill bstIdx               (k > BST k v > v)
#* # backfill bstIns               (k > v > BST k v > BST k v)
#* # backfill bstIsEmpty           (BST k v > Bit)
#* # backfill bstKeysList          (BST k v > List k)
#* # backfill bstWalk              (BST k v > List (k,v))
#* # backfill bstPairsList         (BST k v > List (k,v))
#* # backfill bstPut               (k > v > BST k v > BST k v)
#* # backfill bstSearch            (k > BST k v > Maybe v)
#* # backfill bstSing              (k > v > BST k v)
#* # backfill bstUnion             (BST k v > BST k v > BST k v)
#* # backfill bstValsList          (BST k v > List v)
#* # abstype  (BTree k v)
#* # backfill btEmpty              (BTree k v)
#* # backfill btSing               (k > v > BTree k v)
#* # backfill btSearch             (k > BTree k v > Maybe v)
#* # backfill btHas                (k > BTree k v > Bit)
#* # backfill btGet                (BTree k v > k > v)
#* # backfill btIdx                (k > BTree k v > v)
#* # backfill bstSave              (BST k v > BTree k v)
#* # backfill bstLoad              (BTree k v > BST k v)
#* # backfill btPut                (BTree k v > k > v > BTree k v)

;; sire_20_prp
;; #* # backfill {#getBind}           (Rune)
;; #* # backfill {#getKey}            (Rune) 
;; #* # backfill {#hasProp}           (Rune)
;; #* # backfill {#getProp}           (Rune)
;; #* # backfill getBind              (Str > SireState > Rex > Parser3 Key Pin Bind)
#* # abstype  Bind
#* # abstype  Props
#* # backfill getProps             (Bind > Props)
#* # backfill getProp              (Bind > Str > Any) 

;; sire_21_switch
#* # backfill dataTag              (Any > Nat)

;; sire_22_seed 
#* # backfill pinRefs              (Pin a > Row (Pin Any))
#* # backfill _LoadGerm            (Row (Pin Any) > Bar > Pin a)
#* # backfill _SaveGerm            (Pin a > (Row (Pin Any), Bar))
#* # backfill _LoadSeed            (Bar > Pin a)
#* # backfill _SaveSeed            (Any > Bar)

;; From sire_24_rex exports 
#* # abstype  (Cog i o)
#* # backfill simpleCog       ((a > b) > Cog a b)
#* # abstype  (MaybePair a b)
#* # abstype  BlockState
#* # backfill rexCog          (Cog (MaybePair Nat Rex) o > BlockState > Cog (Maybe Bar) (List o))
#* # typedef  (Monoid a)      (a, (a > a > a))
#* # backfill listMonoid      (Monoid (List a))
#* # abstype  FilePath
#* # backfill blockState      (FilePath > BlockState)

;; From sire_25_datatype exports
#* # backfill typeTag         (Any > Nat)
#* # backfill TRUE            (Bit)
#* # backfill FALSE           (Bit)
#* # backfill LEFT            (a > Either a b)
#* # backfill RIGHT           (b > Either a b)
#* # backfill SOME            (a > Maybe a)
#* # backfill NONE            (Maybe a)
#* # backfill CONS            (a > List a > List a)
#* # backfill NIL             (List a)

infer#add
infer#inc
infer#3
infer#(add 3)
infer#(not (bit 1))
infer#(not TRUE)
infer#(not | bit (add 1 0))

> a > Bit
knot=(compose not bit)

> Bit > Bit
knot=(compose not bit)

> a > b > a
(const x y)=x

> a > b > b
(ignore x y)=y

infer#(x & x)
infer#(x & not (bit x))
infer#(x & x)
infer#(x y & x)
infer#(x y & x)
infer#(x y & y)
infer#(x y & 0)

> a > b > b
(ignore x y)=y

> Bit > Bit
= (knot x) (not | bit x)

infer#(CONS 3 (CONS {foo} NIL))

(**t2 x y)=[x y]
backfill#t2#(a > b > (a,b))

> Bit > Nat > Nat
(addBit x)=(add (toNat x))

> Nat > Nat > Nat
= (countDown x y)
| if (isZero x) x
| countDown (dec x) (dec y)

> Nat > Bit > (Nat, Bit)
= (foo three true)
@ id (x & x) ; let generalization
| t2 (id three) (id true)

> Nat > List Nat
= someOnes
& n
@@ ones (CONS 1 ones)
 | listTake n ones

> Nat > Nat > Nat
= (countDown x y)
| if (isZero x) x
| countDown (dec x) (dec y)
