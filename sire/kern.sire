#### kern <- json

:| sire
:| stew

typedef#ThreadId#Nat
typedef#WorkerId#Nat

abstype#(Promise a)
abstype#(Call a)

= (EVAL f as)            [0 f as]
= (EXEC pump)            [1 pump]

= (DB_READ query)        [0 %read query]
= (DB_WRITE cmd)         [0 %write cmd]
= TIME_WHEN              [%time %when]
= (TIME_WAIT t)          [%time %wait t]
= (TCP_OPEN a p)         [%tcp %open a p]
= (TCP_GIVE h d)         [%tcp %give h d]
= TCP_HEAR               [%tcp %hear]
= (TCP_TAKE h)           [%tcp %take h]
= TCP_MINE               [%tcp %mine]
= (TCP_SHUT h)           [%tcp %shut h]

abstype#(Cog a)
abstype#(Proc a)

= (allocateSlot fr sl rq k)
| trk [%allocateSlot [=fr =sl =rq]]
| if (setIsEmpty fr)
    @ key (len sl)
    @ sl  (rowSnoc sl 0)
    | k key fr sl rq
@ [key fr] | setPop fr
| k key fr sl rq

= (getHandler key k end hl st rd ws)
@ handler | get hl key
| k handler end hl st rd ws

= (COG_DONE result end out hl st rd ws)
| end out hl st rd ws

= (COG_KERNEL out hl st rd ws inputs)
^ _ (listFromRow inputs) ~[] hl st rd ws
? (kernel_loop stream out hl st rd ws)
| ifz stream
  (COG_KERNEL ~[] hl st rd ws, listToRow out)
@ [[pid input] stream] stream
@ exe | get hl pid
| ifz exe
  | kernel_loop stream out hl st rd ws   ; TODO Should maybe cancel the worker too?
@ k   | COG_DONE
@ end | kernel_loop stream
| exe [pid input] k end out hl st rd ws

> Call a > Proc a
= (syscall request k end me fr sl rq)
| trk [%syscall [=request =me =fr =sl =rq]]
@ rq | rowCons (me,request) rq
@ sl | put sl me SOME-k
| end fr sl rq

> Promise a > Proc a
= (await promise k end me fr sl rq)
: input < maybeCase | get sl promise
          @ sl | put sl promise SOME-k
          | end fr sl rq
@ fr | setIns promise fr
@ sl | put sl promise NONE
| k input end me fr sl rq

= (PUMP_DONE _ end me fr sl rq)
| end (setIns me fr) sl rq

;; TODO void_syscall needs to call PUMP_DONE in some way??
;; or maybe that's async's job? fr keeps accumulating slots,
;; but hmm maybe that's actually not due to PUMP_DONE not running,
;; because then it would accumulate even more? it's more like
;; we're not picking them off? but maybe we actually are, just later,
;; because we have lots of promises and open calls?
> Call a > Proc b > Proc b
= (void_syscall request end me fr sl rq)
| trk [%void_syscall [=end =request =me =fr =sl =rq]]
@ rq | rowCons (me,request) rq
@ sl | put sl me NONE
| end fr sl rq

> Proc ThreadId
= (self k end me fr sl rq)
| k me end me fr sl rq

= (PUMP_KERNEL fr sl rq key input)
@ rq  | []                 ; TODO This should be solved in the runtime
@ end | PUMP_KERNEL
: exe < maybeCase | get sl key
        @ sl | put sl key SOME-input
        | end fr sl rq
@ me  | key
@ fr  | setIns key fr
@ sl  | put sl key NONE
| exe input end me fr sl rq

;; TODO we never call PUMP_DONE at the end of void_syscall forks,
;; that's why we never use free slots.
> Proc a > Proc ThreadId
= (pumpFork act k end me fr sl rq)
: tid fr sl rq < allocateSlot fr sl rq
| act PUMP_DONE (k tid end me) tid fr sl rq

= (putState x k end out hl st rd ws)    | k ()   end out hl x    rd ws
= (getState k end out hl st rd ws)      | k st   end out hl st   rd ws
= (getsState f k end out hl st rd ws)   | k f-st end out hl st   rd ws
= (modifyState f k end out hl st rd ws) | k ()   end out hl f-st rd ws
= (stateState f k end out hl st rd ws)  @ (a,st) f-st
                                        | k a    end out hl st   rd ws

= (addWorker worker read write k end out hl st rd ws)
@ wid | len ws
@ ws  | rowSnoc ws worker
@ rd  | put rd 0 | rowSnoc (get rd 0) read
@ hl  | rowSnoc hl write
| k wid end out hl st rd ws

= (exec proc read write)
@ w
  @ k   | PUMP_DONE
  @ end | PUMP_KERNEL
  @ me  | 0
  @ fr  | %[]
  @ sl  | [0]
  @ rq  | []
  | EXEC | proc k end me fr sl rq
| addWorker w read write

= (eval f xs)
| addWorker
* EVAL f xs
* (st query)&(trk [{eval worker tried to read} [=st =query]] 0)
* supply ()

> a > Proc b
= (read query) | syscall | DB_READ query

> (Nat,Nat) > Any > Cog ()
= (send (pid,rid) msg k end out hl st rd ws)
@ out
  | ifz (fst | get ws pid) | out
  | CONS (pid,rid,msg) out
| k () end out hl st rd ws

> ThreadId > Cog a
= (receive wid k end out hl st rd ws)
@ hl | put hl wid k
| end out hl st rd ws


= async | pumpFork

; = (exec worker read write k end out hl st rd ws)
; @ w
;   @ k   | PUMP_DONE
;   @ end | PUMP_KERNEL
;   @ me  | 0
;   @ fr  | ~[]
;   @ sl  | [0]
;   @ rq  | []
;   | worker k end me fr sl rq
; @ wid | len ws
; @ ws  | rowSnoc ws w
; @ hl  | rowSnoc hl write
; | k wid end out hl st rd ws

= (getPumpKernel k end me fr sl rq)
| k [=end =me =fr =sl =rq] end me fr sl rq

= (getCogKernel k end out hl st rd ws)
| k (end,out,hl,st,rd,ws) end out hl st rd ws

= (runCog st cog)
@ k   | COG_DONE
@ end | COG_KERNEL
@ out | ~[]
@ hl  | []
@ rd  | get []
@ ws  | []
| cog k end out hl st rd ws
