#### kern <- json

:| sire
:| stew

typedef#ThreadId#Nat
typedef#WorkerId#Nat

abstype#(Promise a)
abstype#(Call a)

= (JOB f as)            [0 f as]
= (DRIVER driver)       [1 driver]

= (DB_READ query)        [0 %read query]
= (DB_WRITE cmd)         [0 %write cmd]
= TIME_WHEN              [%time %when]
= (TIME_WAIT t)          [%time %wait t]
= (TCP_OPEN a p)         [%tcp %open a p]
= (TCP_GIVE h d)         [%tcp %give h d]
= TCP_HEAR               [%tcp %hear]
= (TCP_TAKE h)           [%tcp %take h]
= TCP_MINE               [%tcp %mine]
= (TCP_SHUT h)           [%tcp %shut h]

abstype#(Cog a)
abstype#(Driver a)

= (allocateSlot fr sl rq k)
| ifz fr
    @ key | len sl
    @ sl  | rowSnoc sl NONE
    | k key fr sl rq
@ [key fr] | fr
@ sl | put sl key NONE
| k key fr sl rq

= (COG_DONE result end out fr hl st rd ws)
| end out fr hl st rd ws

= (COG_KERNEL out fr hl st rd ws inputs)
^ _ (listFromRow inputs) ~[] fr hl st rd ws
? (kernel_loop stream out fr hl st rd ws)
| ifz stream
  (COG_KERNEL ~[] fr hl st rd ws, listToRow out)
@ [[pid input] stream] stream
@ exe | get hl pid
@ tag | fst | get ws pid
@ [fr hl rd ws]
  | if (tag == 1) [fr hl rd ws]
  ++ [pid fr]
  ++ put hl pid 0
  ++ put rd pid 0
  ++ put ws pid 0
| ifz exe
  | kernel_loop stream out fr hl st rd ws   ; TODO Should maybe cancel the worker too?
@ k   | COG_DONE
@ end | kernel_loop stream
| exe pid input k end out fr hl st rd ws

> (Nat > Call a) > Driver (Promise a)
= (fireWith mkRequest k end fr sl rq)
: rid fr sl rq < allocateSlot fr sl rq
@ request | mkRequest rid
@ rq | rowSnoc rq (rid, request)
| k rid end fr sl rq

= (fire req) | fireWith const-req

;; TODO receive and ignore should truncate 0s off of sl
> Promise a > Driver a
= (receive promise k end fr sl rq)
: input < maybeCase | get sl promise
        @ sl | put sl promise SOME-k
        | end fr sl rq
@ fr | [promise fr]
@ sl | put sl promise NONE
| k input end fr sl rq

= (ignore promise k end fr sl rq)
@ fr | [promise fr]
@ sl | put sl promise NONE
| k () end fr sl rq

= (launchWith mkRequest return)
: promise < fireWith mkRequest
| receive promise return

= (launch req) | launchWith const-req

= (launch_ req return)
: promise < fire req
| ignore promise return

= (DRIVER_DONE _ end fr sl rq)
| end fr sl rq

= (DRIVER_KERNEL fr sl rq key input)
@ rq  | []                 ; TODO This should be solved in the runtime
@ end | DRIVER_KERNEL
: exe < maybeCase | get sl key
      @ sl | put sl key SOME-input
      | end fr sl rq
@ fr  | [key fr]
@ sl  | put sl key NONE
| exe input end fr sl rq

= (fork act k end fr sl rq)
| act DRIVER_DONE (k () end) fr sl rq

= (putState x k end out fr hl st rd ws)    | k ()   end out fr hl x    rd ws
= (getState k end out fr hl st rd ws)      | k st   end out fr hl st   rd ws
= (getsState f k end out fr hl st rd ws)   | k f-st end out fr hl st   rd ws
= (modifyState f k end out fr hl st rd ws) | k ()   end out fr hl f-st rd ws
= (stateState f k end out fr hl st rd ws)  @ (a,st) f-st
                                           | k a    end out fr hl st   rd ws

= (addWorker worker read write k end out fr hl st rd ws)
@ wid | len ws
@ ws  | rowSnoc ws worker
@ rd  | put rd 0 | rowSnoc (get rd 0) read
@ hl  | rowSnoc hl write
| k wid end out fr hl st rd ws

= (install driver read write)
@ w
  @ k   | DRIVER_DONE
  @ end | DRIVER_KERNEL
  @ fr  | ~[]
  @ sl  | []
  @ rq  | []
  | DRIVER | driver k end fr sl rq
| addWorker w read write

= (work f xs k end out fr hl st rd ws)
@ w | JOB f xs
@ (read st query) | trk [{job tried to read} [=st =query]] 0
@ handler (_ input _ & k input) ;; TODO kind of ugly, should harmonize w/ drivers
@ [fr ws rd hl]
  | ifz fr
    ++ fr
    ++ rowSnoc ws w
    ++ put rd 0 | rowSnoc (get rd 0) read
    ++ rowSnoc hl handler
  @ [wid fr] | fr
  ++ fr
  ++ put ws wid w
  ++ put rd 0 | put (get rd 0) wid read
  ++ put hl wid handler
| end out fr hl st rd ws

> (Nat,Nat) > Any > Cog ()
= (send (pid,rid) msg k end out fr hl st rd ws)
@ out
  | ifz (fst | get ws pid) | out
  | CONS (pid,rid,msg) out
| k () end out fr hl st rd ws

= (getPumpKernel k end fr sl rq)
| k [=end =fr =sl =rq] end fr sl rq

= (getCogKernel k end out fr hl st rd ws)
| k (end,out,fr,hl,st,rd,ws) end out fr hl st rd ws

= (runCog st cog)
@ k   | COG_DONE
@ end | COG_KERNEL
@ out | ~[]
@ fr  | ~[]
@ hl  | []
@ rd  | get []
@ ws  | []
| cog k end out fr hl st rd ws
