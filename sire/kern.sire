#### kern <- json

:| sire
:| stew

typedef#ThreadId#Nat
typedef#WorkerId#Nat

abstype#(Promise a)
abstype#(Call a)

= (EVAL f as)            [0 f as]
= (EXEC pump)            [1 pump]

= (DB_READ query)        [0 %read query]
= (DB_WRITE cmd)         [0 %write cmd]
= TIME_WHEN              [%time %when]
= (TIME_WAIT t)          [%time %wait t]
= (TCP_OPEN a p)         [%tcp %open a p]
= (TCP_GIVE h d)         [%tcp %give h d]
= TCP_HEAR               [%tcp %hear]
= (TCP_TAKE h)           [%tcp %take h]
= TCP_MINE               [%tcp %mine]
= (TCP_SHUT h)           [%tcp %shut h]

abstype#(Cog a)
abstype#(Proc a)

= (allocateSlot fr sl rq k)
| ifz fr
    @ key | len sl
    @ sl  | rowSnoc sl NONE
    | k key fr sl rq
@ [key fr] | fr
@ sl | put sl key NONE
| k key fr sl rq

;; When making a syscall, we need to record that the rid has been used,
;; to prevent the same rid from being used again.
;; We could store a list of rids that have been used but it seems cleaner
;; to just store NONE in sl.
;; Eventually we should either clear that slot or start listening on it.
;; But we don't know when making the syscall whether we're interested
;; in the response or not.
;; This is what void_syscall was for though.
;; Eventually it seems like it should be possible to implement `void`
;; which replaces that? Or we might be able to implement void_syscall.
;; But the default case should be that we clear manually, i think?
;; `void` can probably be implemented by virtualizing the cog?

= (COG_DONE result end out hl st rd ws)
| end out hl st rd ws

= (COG_KERNEL out hl st rd ws inputs)
^ _ (listFromRow inputs) ~[] hl st rd ws
? (kernel_loop stream out hl st rd ws)
| ifz stream
  (COG_KERNEL ~[] hl st rd ws, listToRow out)
@ [[pid input] stream] stream
@ exe | get hl pid
| ifz exe
  | kernel_loop stream out hl st rd ws   ; TODO Should maybe cancel the worker too?
@ k   | COG_DONE
@ end | kernel_loop stream
| exe pid input k end out hl st rd ws

> Call a > Proc a
= (syscall mkRequest k end fr sl rq)
: rid fr sl rq < allocateSlot fr sl rq
@ request | mkRequest rid
@ rq | rowSnoc rq (rid, request)
| k rid end fr sl rq

;; TODO receive and ignore should truncate 0s off of sl
> Promise a > Proc a
= (receive promise k end fr sl rq)
: input < maybeCase | get sl promise
        @ sl | put sl promise SOME-k
        | end fr sl rq
@ fr | [promise fr]
@ sl | put sl promise NONE
| k input end fr sl rq

= (ignore promise k end fr sl rq)
@ fr | [promise fr]
@ sl | put sl promise NONE
| k () end fr sl rq

= (PUMP_DONE _ end fr sl rq)
| end fr sl rq

= (PUMP_KERNEL fr sl rq key input)
@ rq  | []                 ; TODO This should be solved in the runtime
@ end | PUMP_KERNEL
: exe < maybeCase | get sl key
      @ sl | put sl key SOME-input
      | end fr sl rq
@ fr  | [key fr]
@ sl  | put sl key NONE
| exe input end fr sl rq

= (putState x k end out hl st rd ws)    | k ()   end out hl x    rd ws
= (getState k end out hl st rd ws)      | k st   end out hl st   rd ws
= (getsState f k end out hl st rd ws)   | k f-st end out hl st   rd ws
= (modifyState f k end out hl st rd ws) | k ()   end out hl f-st rd ws
= (stateState f k end out hl st rd ws)  @ (a,st) f-st
                                        | k a    end out hl st   rd ws

= (addWorker worker read write k end out hl st rd ws)
@ wid | len ws
@ ws  | rowSnoc ws worker
@ rd  | put rd 0 | rowSnoc (get rd 0) read
@ hl  | rowSnoc hl write
| k wid end out hl st rd ws

= (exec proc read write)
@ w
  @ k   | PUMP_DONE
  @ end | PUMP_KERNEL
  @ fr  | ~[]
  @ sl  | []
  @ rq  | []
  | EXEC | proc k end fr sl rq
| addWorker w read write

= (eval f xs)
| addWorker
* EVAL f xs
* (st query)&(trk [{eval worker tried to read} [=st =query]] 0)
* supply ()

> (Nat,Nat) > Any > Cog ()
= (send (pid,rid) msg k end out hl st rd ws)
@ out
  | ifz (fst | get ws pid) | out
  | CONS (pid,rid,msg) out
| k () end out hl st rd ws

= (getPumpKernel k end fr sl rq)
| k [=end =fr =sl =rq] end fr sl rq

= (getCogKernel k end out hl st rd ws)
| k (end,out,hl,st,rd,ws) end out hl st rd ws

= (runCog st cog)
@ k   | COG_DONE
@ end | COG_KERNEL
@ out | ~[]
@ hl  | []
@ rd  | get []
@ ws  | []
| cog k end out hl st rd ws
