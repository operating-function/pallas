; Copyright 2024 The opfn Authors
; Use of this source code is governed by a BSD-style license that can be
; found in the LICENSE file.

#### proc_http <- lib_http

:| lib_http

> HTTPBuffer > Bit
= (validRequest request)
; early response for malformed requests - potentially depends on better strategy
; for _short-circuiting_ message chunk ingesting. See processHTTPChunk.
; Goes nicely with error400
TRUE

> HTTPResponse > Bit
= (validResponse response)
; did we get a garbage response from the app?
; if so, we shouldn't send it out.
; return either a bar to be sent out, or nothing (maybe)
; Goes nicely with error500
;
; Do the validation work here. call this in appResponseToHTTP
TRUE

> Tab Bar Bar > Nat > Bar > > Bar > HTTPResponse
= (appResponseToHTTP [headers body code reason])
| ifNot (validResponse b#{TODO})
  | error500 b#{cog error}
@ version      | b#{HTTP/1.0}
@ statusCode   | code
@ reasonPhrase | reason
@ body         | body
@ contentLength | natBar | showNat | barLen body ; should be zero if not present
@ headers | addDefaultHeaders headers
@ headers | tabIns b#{Content-Length} contentLength headers
@ headersList
  | tabValsList
  | tabMapWithKey
  (k v & (barCat [k b#{: } v]))
  headers
| HTTP_RES
* version
* statusCode
* reasonPhrase
* headersList
* body

= (processConnection io getResponse buffer return)
: data < syscall | TCP_TAKE io
| if (barIsEmpty data)
  ; TCP has been SHUT
  | trk [%connectionClosed %dataBarEmpty]
  | return ()
@ updatedBuffer | processHttpChunk buffer data
| ifNot (validRequest updatedBuffer)
  | processConnection io updatedBuffer return
: request < maybeCase (makeRequest updatedBuffer)
          ; valid but incomplete
          | processConnection io updatedBuffer return
; complete and valid
: cogResponse < getResponse request
^ _ (httpResToBar | appResponseToHTTP cogResponse)
? (sendAndClose responseBar)
: mBytes < syscall | TCP_GIVE io responseBar
: bytes  < maybeCase mBytes  | syscall (TCP_SHUT io) return
| if (barLen responseBar == bytes) | syscall (TCP_SHUT io) return
| sendAndClose | barDrop bytes responseBar

= (httpServer responseHandler return)
: port < syscall | TCP_MINE
| trk [%httpRunning (barCat [b#{visit } b#{http://localhost:} (natBar | showNat port)])]
: [io ip port] < syscall | TCP_HEAR
| trk [%theirConnection [=io =ip =port]]
: tid < pumpFork (httpServer responseHandler)
| processConnection io responseHandler (emptyBuffer ip port) return
