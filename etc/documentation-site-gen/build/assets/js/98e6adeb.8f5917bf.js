"use strict";(self.webpackChunkpallas=self.webpackChunkpallas||[]).push([[759],{8263:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>r,default:()=>h,frontMatter:()=>s,metadata:()=>o,toc:()=>c});var i=n(4848),a=n(8453);const s={sidebar_position:5,id:"sire-and-rex",title:"Sire and Rex"},r="Sire",o={id:"explanation/sire-and-rex",title:"Sire and Rex",description:"Sire is a minimalist functional language that bootstraps itself from PLAN. Unlike PLAN, Sire aims to be realistic for humans to write. In service of this goal, it allows programmers to reference previously defined names in an environment, which it uses lambda lifting to eliminate when compiling itself to PLAN.",source:"@site/../../doc/explanation/06_sire-and-rex.md",sourceDirName:"explanation",slug:"/explanation/sire-and-rex",permalink:"/docs/explanation/sire-and-rex",draft:!1,unlisted:!1,editUrl:"https://github.com/operating-function/pallas/edit/main/doc/../../doc/explanation/06_sire-and-rex.md",tags:[],version:"current",sidebarPosition:5,frontMatter:{sidebar_position:5,id:"sire-and-rex",title:"Sire and Rex"},sidebar:"explanationSidebar",previous:{title:"VM and Interpreter",permalink:"/docs/explanation/vm-and-interpreter"}},l={},c=[{value:"Rationale",id:"rationale",level:2},{value:"Rex",id:"rex",level:2}];function d(e){const t={a:"a",h1:"h1",h2:"h2",header:"header",p:"p",...(0,a.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(t.header,{children:(0,i.jsx)(t.h1,{id:"sire",children:"Sire"})}),"\n",(0,i.jsx)(t.p,{children:"Sire is a minimalist functional language that bootstraps itself from PLAN. Unlike PLAN, Sire aims to be realistic for humans to write. In service of this goal, it allows programmers to reference previously defined names in an environment, which it uses [lambda lifting](TK TODO link) to eliminate when compiling itself to PLAN."}),"\n",(0,i.jsxs)(t.p,{children:["For more information on using Sire, see the [tutorial](TK TODO link) and the ",(0,i.jsx)(t.a,{href:"/docs/reference/standard-library/bits-booleans",children:"language reference"}),"."]}),"\n",(0,i.jsx)(t.h2,{id:"rationale",children:"Rationale"}),"\n",(0,i.jsxs)(t.p,{children:["The primary purpose of Sire is to implement more sophisticated languages, which is important because it allows us to achieve a ",(0,i.jsx)(t.a,{href:"/docs/philosophy/philosopy-intro",children:"trustless system"}),": Sire\u2019s compiler is written in just a few thousand lines of Sire, whose syntax is similar enough to ",(0,i.jsx)(t.a,{href:"https://github.com/operating-function/pallas/blob/master/lib/Loot.hs",children:"disassembled PLAN"})," that the compiler \u201cbinary\u201d can be audited by visual comparison to the source code. A more sophisticated language can then simply be implemented directly using Sire source. Nowhere in this chain does the user have to trust an opaque binary. This is in stark contrast to most high level languages which can only be compiled with trusted binaries which are often practically impossible to bootstrap from a high-trust foundation."]}),"\n",(0,i.jsx)(t.p,{children:"While Sire is untyped, it has built-in support for unit tests as a basic code verification measure. The language supports both reflection and reification \u2013 it can examine its environment, syntax and terms, and can dynamically construct new code, as well as extend and replace its own syntax through macros. Changing the language in this way gives us a concrete trustless path to an arbitrary number of more advanced languages with better affordances for enforcing correctness and compositionality, using types and other static analysis techniques."}),"\n",(0,i.jsx)(t.h2,{id:"rex",children:"Rex"}),"\n",(0,i.jsx)(t.p,{children:"Sire uses an unusual syntax called Rex. It\u2019s not necessary to understand Rex to use Sire, except when using macros to change or extend the syntax. Rex is a completely regular and data-oriented abstract syntax that still has a very flexible and expressive concrete syntax thanks to several different input modes. A language implementation that uses Rex would typically transform abstract Rex trees into its own AST, and then compile that to PLAN or interpret it directly, but a Rex tree also contains information on the concrete input mode used in source code."}),"\n",(0,i.jsx)(t.p,{children:"The point of Rex is to decouple the syntax from the semantics in a way similar to how Lisps tend to use S-expressions, but to also give language developers the ability to offer programmers cleaner and more readable syntaxes than what S-expressions can support. This supports rapid iteration of language designs by removing the need to write new lexers, parsers, pretty printers, and allows optimization code to be shared."}),"\n",(0,i.jsxs)(t.p,{children:["To understand Rex, see the ",(0,i.jsx)(t.a,{href:"/docs/reference/standard-library/rex",children:"reference"}),". To use it, see the ",(0,i.jsx)(t.a,{href:"/docs/tutorial/intro",children:"tutorial"})," and ",(0,i.jsx)(t.a,{href:"/docs/reference/sire-runes-macros#macros",children:"reference"})," on Sire\u2019s macro system."]})]})}function h(e={}){const{wrapper:t}={...(0,a.R)(),...e.components};return t?(0,i.jsx)(t,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}},8453:(e,t,n)=>{n.d(t,{R:()=>r,x:()=>o});var i=n(6540);const a={},s=i.createContext(a);function r(e){const t=i.useContext(s);return i.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function o(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:r(e.components),i.createElement(s.Provider,{value:t},e.children)}}}]);