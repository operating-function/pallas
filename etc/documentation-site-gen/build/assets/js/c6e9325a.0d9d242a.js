"use strict";(self.webpackChunkpallas=self.webpackChunkpallas||[]).push([[831],{2511:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>s,default:()=>p,frontMatter:()=>o,metadata:()=>r,toc:()=>c});var a=t(4848),i=t(8453);const o={title:"PLAN"},s="PLAN",r={id:"explanation/plan",title:"PLAN",description:"The previous section provided an overview of the system and how the different components contribute to its overall functioning. Let\u2019s now take a closer look at each component, starting with PLAN.",source:"@site/../../doc/explanation/02_plan.md",sourceDirName:"explanation",slug:"/explanation/plan",permalink:"/explanation/plan",draft:!1,unlisted:!1,editUrl:"https://github.com/operating-function/pallas/edit/main/doc/../../doc/explanation/02_plan.md",tags:[],version:"current",sidebarPosition:2,frontMatter:{title:"PLAN"},sidebar:"explanationSidebar",previous:{title:"System Overview",permalink:"/"},next:{title:"Data Model",permalink:"/explanation/plan-data-model"}},l={},c=[];function d(e){const n={a:"a",code:"code",h1:"h1",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",...(0,i.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(n.p,{children:"The previous section provided an overview of the system and how the different components contribute to its overall functioning. Let\u2019s now take a closer look at each component, starting with PLAN."}),"\n",(0,a.jsx)(n.header,{children:(0,a.jsx)(n.h1,{id:"plan",children:"PLAN"})}),"\n",(0,a.jsx)(n.p,{children:"Nearly every core innovation of Pallas emerges from the design of PLAN. PLAN is the \u201cbytecode\u201d of Pallas, but in contrast to bytecode, it is human readable. It is a Turing-complete evaluation model which is purely functional, lazy and reflective. It is designed to strike a reasonable balance between several different design requirements:"}),"\n",(0,a.jsxs)(n.ol,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Human Readability"}),': Unlike typical low-level formats, PLAN maintains a degree of readability that allows developers to inspect and understand "binaries" directly.']}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Functional Compile Target"}),": PLAN serves as an excellent target for functional language compilers."]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Efficient Memory Representation"}),": The structure of PLAN is designed to map well to in-memory data structures, allowing for efficient execution."]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Database Oriented"}),": PLAN is purpose-built for personal databases, offering a \u201csingle-level store\u201d."]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Ease of Implementation"}),": PLAN is possible to implement efficiently in a few thousand lines of code."]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Extensibility and Modifiability"}),": PLAN allows programs to both construct new programs and inspect existing ones \u2013 including themselves. This allows them to upgrade and extend themselves, effectively running forever."]}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:"It's not necessary to understand PLAN to program Pallas, but if you understand PLAN, you'll understand at least half of the system. Here is an informal pseudocode specification of PLAN, followed by an explanation:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-unset",children:"Each value is a pin x:<i>, a law x:{n a b}, an app x:(f g), or a nat x:@.\n\nTreat this as a combinator system, and use normal-order evaluation to normalize.\nUnmatched patterns diverge.\n\n    (0 n a b) | NAT(a)>0 = {NAT(n) NAT(a) force(b)}  \n    (1 p _ _ _ <x>)      = (p x)  \n    (1 _ l _ _ {n a b})  = (l n a b)  \n    (1 _ _ a _ (f x))    = (a f x)  \n    (1 _ _ _ n x:@)      = (n x)  \n    (2 z p x)            = n=NAT(x); if n=0 then z else p (n-1)  \n    (3 x)                = NAT(x)+1  \n    (4 x)                = <force(x)>  \n    (f:{n a b} x0..xn)   = EXEC([f x0..xn], b)  \n    (f:<{n a b}> x0..xn) = EXEC([f x0..xn], b)  \n    (<i> ..)             = (i ..)\n\n    NAT(x:@) = x  \n    NAT(_)   = 0\n\n    EXEC(e, n:@) | n<len(e) = e[n]  \n    EXEC(e, (0 x y))        = (EXEC(x) EXEC(y))  \n    EXEC(e, (1 v b))        = EXEC(f,b) where f = e ++ [EXEC(f,v)]  \n    EXEC(e, (2 x))          = x  \n    EXEC(e, x)              = x\n"})}),"\n",(0,a.jsxs)(n.p,{children:["This informal specification glosses over some details regarding evaluation order and normalization, but is otherwise correct. For a more detailed and implementation-oriented specification, see the ",(0,a.jsx)(n.a,{href:"/reference/plan/",children:"reference"}),"."]}),"\n",(0,a.jsx)(n.p,{children:"To start, we can note that the specification contains three things: at the top there\u2019s a data model, which is then followed by a few informal instructions and finally a number of rewrites over the data model. We\u2019ll go through the data model, then the rewrite rules, and finally the informal instructions."})]})}function p(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,a.jsx)(n,{...e,children:(0,a.jsx)(d,{...e})}):d(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>s,x:()=>r});var a=t(6540);const i={},o=a.createContext(i);function s(e){const n=a.useContext(o);return a.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function r(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:s(e.components),a.createElement(o.Provider,{value:n},e.children)}}}]);