"use strict";(self.webpackChunkpallas=self.webpackChunkpallas||[]).push([[890],{9486:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>o,contentTitle:()=>r,default:()=>h,frontMatter:()=>s,metadata:()=>l,toc:()=>c});var t=i(4848),a=i(8453);const s={id:"plan-reference",title:"PLAN"},r="PLAN reference",l={id:"reference/plan/plan-reference",title:"PLAN",description:"Reference for implementing a PLAN interpreter",source:"@site/../../doc/reference/plan/plan.md",sourceDirName:"reference/plan",slug:"/reference/plan/",permalink:"/docs/reference/plan/",draft:!1,unlisted:!1,editUrl:"https://github.com/operating-function/pallas/edit/main/doc/../../doc/reference/plan/plan.md",tags:[],version:"current",frontMatter:{id:"plan-reference",title:"PLAN"},sidebar:"referenceSidebar",previous:{title:"Effects Reference",permalink:"/docs/reference/vm-and-interpreter/effects-reference"}},o={},c=[{value:"Law body EDSL",id:"law-body-edsl",level:2},{value:"Evaluation in detail",id:"evaluation-in-detail",level:2},{value:"Black Holes (<code>&lt;&gt;</code>)",id:"black-holes-",level:3},{value:"<code>X</code> (function eXecution)",id:"x-function-execution",level:3},{value:"<code>B</code> (Build law environment)",id:"b-build-law-environment",level:3},{value:"<code>R</code> (Run a law)",id:"r-run-a-law",level:3},{value:"<code>E</code> (Evaluate)",id:"e-evaluate",level:3},{value:"<code>F</code> (Force normalize)",id:"f-force-normalize",level:3},{value:"<code>P</code> (Pattern match)",id:"p-pattern-match",level:3},{value:"<code>N</code> (cast to Nat)",id:"n-cast-to-nat",level:3},{value:"<code>I</code> (index",id:"i-index",level:3},{value:"<code>A</code> (Arity)",id:"a-arity",level:3},{value:"<code>L</code> (Let-binding)",id:"l-let-binding",level:3},{value:"<code>C</code> (reCursion on naturals)",id:"c-recursion-on-naturals",level:3},{value:"<code>S</code> (Saturate)",id:"s-saturate",level:3},{value:"<code>W</code> (Write law)",id:"w-write-law",level:3}];function d(e){const n={a:"a",admonition:"admonition",blockquote:"blockquote",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,a.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.header,{children:(0,t.jsx)(n.h1,{id:"plan-reference",children:"PLAN reference"})}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsx)(n.p,{children:"Reference for implementing a PLAN interpreter"}),"\n"]}),"\n",(0,t.jsx)(n.admonition,{title:"TODO",type:"warning",children:(0,t.jsx)(n.p,{children:"Forthcoming"})}),"\n",(0,t.jsx)(n.p,{children:"Pseudocode specification of PLAN:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-unset",children:'Every PLAN value is either a pin x:<i>, a law x:{n a b}, an app x:(f g),\na nat x:@, or a black hole x:<>.  Black holes only exist during evaluation.\n\n(o <- x) mutates o in place, updating its value to equal x.\n\nUnmatched patterns diverge.\n\nRun F[x] to normalize a value, to "evaluate".\n\nF[o] =                                  | N[o] = E[o]; if o:@ then o else 0\n    E[o]                                |\n    when o:(f x)                        | C[z,p,n] = if n=0 then z else p (n-1)\n         F[f]; F[x]                     |\n    o                                   | S[o:(f x y)]       = (S[(f x)] y)\n                                        | S[o:(<{n a b}> y)] = o\nE[o] =                                  | S[o:(<f> x)]       = S[(f x)]\n    when o:(f x)                        | S[o]               = o\n        E[f]                            |\n        when A[f]=1                     | I[f, (e x), 0] = x\n            o <- S[o]                   | I[f, e,     0] = e\n            o <- X[o,o]                 | I[f, (e x), n] = I[f, e, n-1]\n            E[o]                        | I[f, e,     n] = f\n    o                                   |\n                                        | A[(f x)]     = A[f]-1\nX[(f x), e]         = X[f,e]            | A[<p>]       = A[p]\nX[<p>, e]           = X[p,e]            | A[{n a b}]   = a\nX[{n a b}, e]       = B[a,a,e,b,b]      | A[n:@]       = I[1, (3 5 3), n]\nX[0, (_ n a b)]     = W[N[n],N[a],F[b]] |\nX[1, (_ p l a n x)] = P[p,l,a,n,E[x]]   | R[n,e,b:@] | b\u2264n = I[_,e,(n-b)]\nX[2, (_ z p x)]     = C[z,p,N[x]]       | R[n,e,(0 f x)]   = (R[n,e,f] R[n,e,x])\nX[3, (_ x)]         = N[x]+1            | R[n,e,(2 x)]     = x\nX[4, (_ x)]         = <F[x]>            | R[n,e,x]         = x\n                                        |\nL[i,n,e,(1 v b)] = I[_,e,i] <- R[n,e,v] | P[p,l,a,n,(f x)]   = (a f x)\n                   L[i+1,n,e,b]         | P[p,l,a,n,<x>]     = (p x)\nL[_,n,e,x]       = R[n,e,x]             | P[p,l,a,n,{n a b}] = (l n a b)\n                                        | P[p,l,a,n,x:@]     = (n x)\nB[a,n,e,b,(1 _ k)] = B[a,n+1,(e <>),b,k]|\nB[a,n,e,b,x]       = L[a,n,e,b]         | W[n,a,b] | n>0 = {n,a,b}\n'})}),"\n",(0,t.jsx)(n.h2,{id:"law-body-edsl",children:"Law body EDSL"}),"\n",(0,t.jsx)(n.p,{children:"PLAN contains an embedded domain-specific language (EDSL) for defining law bodies. This EDSL is not a separate language per se, but rather a specific way of using PLAN constructs to represent law bodies. The B, L and R operations together define the semantics of this EDSL. Before going into these, it is informative to look at the EDSL for law bodies in the abstract. It doesn\u2019t have a syntax, but if it did, it would look something like this:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-unset",children:"LawBody ::= Self                   -- self-reference\n          | Var Nat                -- var-reference (index into environment)\n          | Literal PLAN           -- produce literal value\n          | Apply LawBody LawBody  -- function application\n          | let LawBody in LawBody -- let binding (append to environment)\n"})}),"\n",(0,t.jsx)(n.p,{children:"The EDSL and PLAN proper are tightly intertwined:"}),"\n",(0,t.jsxs)(n.p,{children:["Within a law body, you can always drop back into regular PLAN either by using the ",(0,t.jsx)(n.code,{children:"Literal"})," construct (encoded using 2), or automatically when a part of the law body doesn't have meaning in the EDSL.\nConversely, PLAN switches into the EDSL whenever executing a law."]}),"\n",(0,t.jsx)(n.p,{children:"This dual-language structure allows PLAN to maintain a simple core while providing more expressive power for defining functions."}),"\n",(0,t.jsx)(n.h2,{id:"evaluation-in-detail",children:"Evaluation in detail"}),"\n",(0,t.jsx)(n.p,{children:'We\'ll look at each of the operations that appear the PLAN spec. But first, we have to cover "black holes":'}),"\n",(0,t.jsxs)(n.h3,{id:"black-holes-",children:["Black Holes (",(0,t.jsx)(n.code,{children:"<>"}),")"]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.code,{children:"<>"})," are temporary placeholders used during evaluation to handle recursive bindings and thunks. They serve several purposes:"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"As mutable placeholders during environment building"}),"\n",(0,t.jsx)(n.li,{children:"During evaluation of null-ary laws (E operation)"}),"\n",(0,t.jsx)(n.li,{children:"As detection for cyclic evaluations:"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Black holes only exist during evaluation and should never appear in final normalized values."})}),"\n",(0,t.jsxs)(n.h3,{id:"x-function-execution",children:[(0,t.jsx)(n.code,{children:"X"})," (function eXecution)"]}),"\n",(0,t.jsx)(n.p,{children:'The relevant part of the pseudocode specification is the X operation, short for "eXecute":'}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-unset",children:"X[0, (_ n a b)]     = W[N[n],N[a],F[b]]\nX[1, (_ p l a n x)] = P[p,l,a,n,E[x]]\nX[2, (_ z p x)]     = C[z,p,N[x]]\nX[3, (_ x)]         = N[x]+1\nX[4, (_ x)]         = <F[x]>\nX[(f x), e]         = X[f,e]\nX[<p>, e]           = X[p,e]\nX[{n a b}, e]       = B[a,a,e,b,b]\n"})}),"\n",(0,t.jsx)(n.p,{children:"X takes two arguments, a function and an environment that it should be executed in. Most of the time, the environment simply is simply the function itself followed by all its arguments. X is defined by eight different cases. The first five cases define the opcodes, the built in functions. Let\u2019s look at them one by one."}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["0 creates a law. (0 n a b) casts n and a to nats, forces recursive evaluation of b, and creates a law with name n, arity a and body b. See also the ",(0,t.jsx)(n.a,{href:"#w-write-law",children:"W  operation"}),"."]}),"\n",(0,t.jsxs)(n.li,{children:["1 reflects by pattern matching. (1 p l a n x) evaluates an arbitrary PLAN value x, inspects the result, and depending on its shape, chooses one of the branches p, l, a or n. See also the ",(0,t.jsx)(n.a,{href:"#p-pattern-match",children:"P operation"}),"."]}),"\n",(0,t.jsxs)(n.li,{children:["2 is structural recursion on nats. (2 z p x) casts an arbitrary PLAN value x to a nat, and branches on whether the result is 0 or not. See also the ",(0,t.jsx)(n.a,{href:"#c-recursion-on-naturals",children:"C operation"}),"."]}),"\n",(0,t.jsx)(n.li,{children:"3 is increment. (3 x) casts x to a nat and increments the result by 1."}),"\n",(0,t.jsx)(n.li,{children:"4 pins a value. (4 x) forces normalization of x and puts it inside a pin. All realistic interpreters will also hash x and, if a value with the same hash already exists, deduplicate it."}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"The three final cases define what it means to execute functions that aren\u2019t built-in."}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"If the function is an app (f x), the argument x is already included in the environment (remember that apps are closures; they define the environment), so we ignore it and simply recurse deeper to execute the actual function."}),"\n",(0,t.jsx)(n.li,{children:"If the function is a pin, executing it is the same as executing the function inside the pin."}),"\n",(0,t.jsx)(n.li,{children:"If the function is a law, we need to interpret the law body. This starts by building the environment, which is done using the B operation. Note that the law\u2019s name isn\u2019t used at all, it is only there to increase readability."}),"\n"]}),"\n",(0,t.jsxs)(n.h3,{id:"b-build-law-environment",children:[(0,t.jsx)(n.code,{children:"B"})," (Build law environment)"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-unset",children:"B[a,n,e,b,(1 _ k)] = B[a,n+1,(e <>),b,k]\nB[a,n,e,b,x]       = L[a,n,e,b]\n"})}),"\n",(0,t.jsx)(n.p,{children:"This operation builds the environment for executing a law body by processing any let bindings. It takes four arguments:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"a: The initial arity/position for binding values"}),"\n",(0,t.jsx)(n.li,{children:"n: The current size of the environment"}),"\n",(0,t.jsx)(n.li,{children:"e: The current environment"}),"\n",(0,t.jsx)(n.li,{children:"b: The law body to evaluate"}),"\n",(0,t.jsx)(n.li,{children:"An optional fifth argument for let binding cases"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"It works recursively:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["When encountering a let binding (1 _ k), it:","\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["Extends the environment with a black hole placeholder (",(0,t.jsx)(n.code,{children:"<>"}),")"]}),"\n",(0,t.jsx)(n.li,{children:"Increments the environment size"}),"\n",(0,t.jsx)(n.li,{children:"Recursively processes the rest of the bindings in k"}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(n.li,{children:"For non-let-binding values, passes control to L to evaluate the final body"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"The black holes serve as mutable placeholders that will be filled in during evaluation by the L operation."}),"\n",(0,t.jsxs)(n.h3,{id:"r-run-a-law",children:[(0,t.jsx)(n.code,{children:"R"})," (Run a law)"]}),"\n",(0,t.jsx)(n.p,{children:"This EDSL for law bodies is implemented by the R operation:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-unset",children:"R(n,e,b:@) | b\u2264n = I(b,e,(n-b))         # if b=0 Self, otherwise Var b\nR(n,e,(0 f x))   = (R(n,e,f) R(n,e,x))  # Apply f x\nR(n,e,(1 v b))   = L(n,e,v,b)           # let v in b\nR(n,e,(2 x))     = x                    # Literal x\nR(n,e,x)         = x                    # Literal x (fallback, incl b>n)\n"})}),"\n",(0,t.jsx)(n.p,{children:"It's important to note that none of these patterns reduce under the normal PLAN evaluation rules defined by the X operation. The arities of the opcodes 0, 1 and 2 in the apps aren\u2019t saturated, so the apps are kept as inert values. This allows any valid expression in the EDSL to be stored using this encoding."}),"\n",(0,t.jsxs)(n.h3,{id:"e-evaluate",children:[(0,t.jsx)(n.code,{children:"E"})," (Evaluate)"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-unset",children:"E(o:@)     = o\nE(o:<x>)   = o\nE(o:(f x)) =\n   E(f)\n   when A(f)=1\n       o <- X(o,o)\n       E(o)\n   o\nE(o:{n a b}) =\n    if a!=0 then o else\n       o <- <>\n       o <- R(0,o,b)\n       E(o)\n"})}),"\n",(0,t.jsxs)(n.p,{children:["This evaluates an arbitrary PLAN expression to weak-head normal form and ",(0,t.jsx)(n.em,{children:"replaces"})," it with the result in memory. This is important! E is a stateful operation. If the evaluated PLAN expression occurs in several locations on the heap due to structural sharing, all of them will change. This is how PLAN implements thunks."]}),"\n",(0,t.jsxs)(n.h3,{id:"f-force-normalize",children:[(0,t.jsx)(n.code,{children:"F"})," (Force normalize)"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-unset",children:"F(o) =\n    E(o)\n    when o:(f x)\n         F(f); F(x)\n    o\n"})}),"\n",(0,t.jsx)(n.p,{children:"This is a helper operation that X uses to implement opcode 4. It recursively forces evaluation of an arbitrary PLAN expression, putting it into normal form."}),"\n",(0,t.jsxs)(n.h3,{id:"p-pattern-match",children:[(0,t.jsx)(n.code,{children:"P"})," (Pattern match)"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-unset",children:"P(p,l,a,n,(f x))   = (a f x)\nP(p,l,a,n,<x>)     = (p x)\nP(p,l,a,n,{n a b}) = (l n a b)\nP(p,l,a,n,x:@}     = (n x)\n"})}),"\n",(0,t.jsx)(n.p,{children:"This is a helper operation that X uses to implement opcode 1. It branches based on the structure of the PLAN value that is being inspected, passing the components to the appropriate continuation. This is what makes PLAN a fully reflective system."}),"\n",(0,t.jsxs)(n.h3,{id:"n-cast-to-nat",children:[(0,t.jsx)(n.code,{children:"N"})," (cast to Nat)"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-unset",children:"N(o) = E(o); if o:@ then o else 0\n"})}),"\n",(0,t.jsx)(n.p,{children:"This is a helper operation that X uses to implement opcodes 0 and 3. It evaluates a PLAN expression and casts the result to a nat by simply returning 0 for non-nat values."}),"\n",(0,t.jsxs)(n.h3,{id:"i-index",children:[(0,t.jsx)(n.code,{children:"I"})," (index"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-unset",children:"I(f, (e x), 0) = x\nI(f, e,     0) = e\nI(f, (e x), n) = I(f, e, n-1)\nI(f, e,     n) = f\n"})}),"\n",(0,t.jsx)(n.p,{children:"This is a helper operation used by A and R. It takes a fallback case, an environment to index into \u2013 typically a nested app tree \u2013 and an index. It\u2019s defined by recursion on the environment: if the index is 0, we\u2019ve reached the bottom and should return either the tail or, if that\u2019s not possible, the whole environment. If the index is greater than 0, we recur and decrement the index. If we can\u2019t recur, we\u2019re out of bounds and return the fallback case."}),"\n",(0,t.jsx)(n.p,{children:"It\u2019s worth noting that indices work from right to left instead of from left to right. This is because apps associate to the left. We could go in the other direction, but this would complicate the specification significantly without making any fundamental difference. Additionally, realistic implementations will have optimized nested app trees to arrays either way, so this change wouldn\u2019t make implementation easier."}),"\n",(0,t.jsxs)(n.h3,{id:"a-arity",children:[(0,t.jsx)(n.code,{children:"A"})," (Arity)"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-unset",children:"A((f x))     = A(f)-1\nA(<p>)       = A(p)\nA({n a b})   = a\nA(n:@)       = I(1, (3 5 3), n)\n"})}),"\n",(0,t.jsx)(n.p,{children:"This is a helper operation used by E. It simply returns the arity of a PLAN expression if interpreted as a function. The first three cases should be obvious. The arities of nats are hardcoded according to this table, which is implemented by the call to I, where 1 is a default value."}),"\n",(0,t.jsxs)(n.table,{children:[(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"nat"}),(0,t.jsx)(n.th,{children:"arity"}),(0,t.jsx)(n.th,{children:"comment"})]})}),(0,t.jsxs)(n.tbody,{children:[(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"0"}),(0,t.jsx)(n.td,{children:"3"}),(0,t.jsx)(n.td,{children:"opcode \u201ccreate a law\u201d"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"1"}),(0,t.jsx)(n.td,{children:"5"}),(0,t.jsx)(n.td,{children:"opcode \u201creflect\u201d"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"2"}),(0,t.jsx)(n.td,{children:"3"}),(0,t.jsx)(n.td,{children:"opcode \u201cis zero?\u201d"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"3"}),(0,t.jsx)(n.td,{children:"1"}),(0,t.jsx)(n.td,{children:"opcode \u201cincrement\u201d"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"4"}),(0,t.jsx)(n.td,{children:"1"}),(0,t.jsx)(n.td,{children:"opcode \u201cmake pin\u201d"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"n"}),(0,t.jsx)(n.td,{children:"1"}),(0,t.jsx)(n.td,{children:"crash with message m"})]})]})]}),"\n",(0,t.jsxs)(n.h3,{id:"l-let-binding",children:[(0,t.jsx)(n.code,{children:"L"})," (Let-binding)"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-unset",children:"L(n,e,v,b) =\n    x := <>\n    f := (e x)\n    x <- R(n+1,f,v)\n    R(n+1,f,b)\n"})}),"\n",(0,t.jsx)(n.p,{children:"This is a helper operation that is mutually recursive with R. It takes:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"i: The current binding position index (for multiple let bindings)"}),"\n",(0,t.jsx)(n.li,{children:"n: The environment size"}),"\n",(0,t.jsx)(n.li,{children:"e: The environment to extend with new value v"}),"\n",(0,t.jsx)(n.li,{children:"v: The value being bound (in let cases)"}),"\n",(0,t.jsx)(n.li,{children:"b: law body which should run against the environment after it has been extended with v"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"For non-let cases, it simply runs the body in the current environment using R."}),"\n",(0,t.jsxs)(n.h3,{id:"c-recursion-on-naturals",children:[(0,t.jsx)(n.code,{children:"C"})," (reCursion on naturals)"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-unset",children:"C[z,p,n] = if n=0 then z else p (n-1)\n"})}),"\n",(0,t.jsx)(n.p,{children:"This is a helper operation that X uses to implement opcode 2. It implements primitive recursion on natural numbers, taking three arguments:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"A base case z to return when n=0"}),"\n",(0,t.jsx)(n.li,{children:"A successor case function p to apply to (n-1) when n>0"}),"\n",(0,t.jsx)(n.li,{children:"A natural number n to recurse on"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"This allows PLAN to implement structural recursion without needing explicit recursion primitives in the core language. When opcode 2 is executed via X[2, (_ z p x)], it evaluates x to a natural number and then uses C to either return the base case z (if x=0) or apply p to x-1 (if x>0)."}),"\n",(0,t.jsxs)(n.h3,{id:"s-saturate",children:[(0,t.jsx)(n.code,{children:"S"})," (Saturate)"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-unset",children:"S[o:(f x y)]       = (S[(f x)] y)\nS[o:(<{n a b}> y)] = o\nS[o:(<f> x)]       = S[(f x)]\nS[o]               = o\n"})}),"\n",(0,t.jsx)(n.p,{children:"This is a helper operation that E uses during evaluation. It handles saturation of function applications - determining when a function has received enough arguments to evaluate. The rules handle several cases:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"For nested applications (f x y), recurse left-associatively by first saturating (f x) and then applying y"}),"\n",(0,t.jsxs)(n.li,{children:["For a pinned law being applied ",(0,t.jsx)(n.code,{children:"(<{n a b}> y)"}),", preserve the entire expression"]}),"\n",(0,t.jsxs)(n.li,{children:["For a pinned function being applied ",(0,t.jsx)(n.code,{children:"(<f> x)"}),", recurse into the application"]}),"\n",(0,t.jsx)(n.li,{children:"For any other value, return it unchanged"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"S is called during evaluation when a function of arity 1 is encountered, ensuring proper handling of nested applications and pinned values before execution continues."}),"\n",(0,t.jsxs)(n.h3,{id:"w-write-law",children:[(0,t.jsx)(n.code,{children:"W"})," (Write law)"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-unset",children:"W[n,a,b] | n>0 = {n,a,b}\n"})}),"\n",(0,t.jsx)(n.p,{children:"This is a helper operation that X uses to implement opcode 0 (law creation). It constructs a law value only if the law's name is a positive natural number, enforcing a basic validation rule on law definitions. The operation takes three arguments:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"A natural number n for the law's name, which must be >0"}),"\n",(0,t.jsx)(n.li,{children:"A natural number a specifying the law's arity"}),"\n",(0,t.jsx)(n.li,{children:"A value b containing the law's body"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:'When opcode 0 is executed via X[0, (_ n a b)], it first normalizes its arguments using N[n], N[a], and F[b] respectively, then attempts to construct a law using W. If the normalized name is 0 or negative, the operation will diverge according to the "Unmatched patterns diverge" rule, preventing the creation of invalid laws.\nThe validation that n>0 ensures all laws in the system have proper positive natural number identifiers, which may be important for the reflection capabilities provided by opcode 1.'})]})}function h(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(d,{...e})}):d(e)}},8453:(e,n,i)=>{i.d(n,{R:()=>r,x:()=>l});var t=i(6540);const a={},s=t.createContext(a);function r(e){const n=t.useContext(s);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:r(e.components),t.createElement(s.Provider,{value:n},e.children)}}}]);