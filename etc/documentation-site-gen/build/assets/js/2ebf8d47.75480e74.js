"use strict";(self.webpackChunkpallas=self.webpackChunkpallas||[]).push([[959],{7889:(e,n,a)=>{a.r(n),a.d(n,{assets:()=>r,contentTitle:()=>s,default:()=>h,frontMatter:()=>l,metadata:()=>o,toc:()=>d});var t=a(4848),i=a(8453);const l={sidebar_position:3,id:"plan-evaluation-model",title:"Evaluation Model"},s="PLAN Evaluation model",o={id:"explanation/plan-evaluation-model",title:"Evaluation Model",description:"So far we\u2019ve only looked at PLAN as inert data. We\u2019ve hinted at dynamics, but we haven\u2019t given any details. Let\u2019s go through the rest of the specification chunk by chunk.",source:"@site/../../doc/explanation/03_PLAN-evaluation-model.md",sourceDirName:"explanation",slug:"/explanation/plan-evaluation-model",permalink:"/docs/explanation/plan-evaluation-model",draft:!1,unlisted:!1,editUrl:"https://github.com/operating-function/pallas/edit/main/doc/../../doc/explanation/03_PLAN-evaluation-model.md",tags:[],version:"current",sidebarPosition:3,frontMatter:{sidebar_position:3,id:"plan-evaluation-model",title:"Evaluation Model"},sidebar:"explanationSidebar",previous:{title:"Data Model",permalink:"/docs/explanation/plan-data-model"},next:{title:"VM and Interpreter",permalink:"/docs/explanation/vm-and-interpreter"}},r={},d=[{value:"Opcodes",id:"opcodes",level:2},{value:"Opcode 0 (create a law)",id:"opcode-0-create-a-law",level:3},{value:"Opcode 1 (reflect)",id:"opcode-1-reflect",level:3},{value:"Opcode 2 (nat iteration)",id:"opcode-2-nat-iteration",level:3},{value:"Opcode 3 (increment)",id:"opcode-3-increment",level:3},{value:"Opcode 4 (create pin)",id:"opcode-4-create-pin",level:3},{value:"Law execution",id:"law-execution",level:2},{value:"<em>References</em>",id:"references",level:4},{value:"<em>Function application</em>",id:"function-application",level:4},{value:"<em>Let-binding</em>",id:"let-binding",level:4},{value:"<em>Literals</em>",id:"literals",level:4},{value:"Pin application",id:"pin-application",level:4},{value:"Evaluation order",id:"evaluation-order",level:2},{value:"Seed (de/serialization)",id:"seed-deserialization",level:2},{value:"Loot (disassembly)",id:"loot-disassembly",level:2}];function c(e){const n={a:"a",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,i.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.header,{children:(0,t.jsx)(n.h1,{id:"plan-evaluation-model",children:"PLAN Evaluation model"})}),"\n",(0,t.jsx)(n.p,{children:"So far we\u2019ve only looked at PLAN as inert data. We\u2019ve hinted at dynamics, but we haven\u2019t given any details. Let\u2019s go through the rest of the specification chunk by chunk."}),"\n",(0,t.jsx)(n.h2,{id:"opcodes",children:"Opcodes"}),"\n",(0,t.jsx)(n.h3,{id:"opcode-0-create-a-law",children:"Opcode 0 (create a law)"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-unset",children:"(0 n a b) | NAT(a)>0 = {NAT(n) NAT(a) force(b)}\n"})}),"\n",(0,t.jsx)(n.p,{children:"0 creates a law. It casts n and a to nats, forces recursive evaluation of b, and creates a law with name n, arity a and body b. This allows code to construct code. force here is simply saying that the entire body should be recursively evaluated, while NAT is a helper function that returns 0 for all non-nat values:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-unset",children:"NAT(x:@) = x  \nNAT(_)   = 0\n"})}),"\n",(0,t.jsx)(n.h3,{id:"opcode-1-reflect",children:"Opcode 1 (reflect)"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-unset",children:"(1 p _ _ _ <x>)      = (p x)  \n(1 _ l _ _ {n a b})  = (l n a b)  \n(1 _ _ a _ (f x))    = (a f x)\n(1 _ _ _ n x:@)      = (n x)\n"})}),"\n",(0,t.jsx)(n.p,{children:"1 reflects on any PLAN value by pattern matching. Depending on whether the last argument is a pin, law, app or nat, the appropriate continuation will be chosen and evaluated. This is what makes PLAN a fully reflective system."}),"\n",(0,t.jsx)(n.h3,{id:"opcode-2-nat-iteration",children:"Opcode 2 (nat iteration)"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-unset",children:"(2 z p x)            = n=NAT(x); if n=0 then z else p (n-1)\n"})}),"\n",(0,t.jsx)(n.p,{children:"2 is nat iteration. It allows us to iterate up to x times. The last argument is cast to a nat, and depending on whether the result is 0 or not, we either default to the base case or run the successor case."}),"\n",(0,t.jsx)(n.h3,{id:"opcode-3-increment",children:"Opcode 3 (increment)"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-unset",children:"(3 x)                = NAT(x)+1\n"})}),"\n",(0,t.jsx)(n.p,{children:"3 increments. It casts x to a nat and adds 1."}),"\n",(0,t.jsx)(n.h3,{id:"opcode-4-create-pin",children:"Opcode 4 (create pin)"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-unset",children:"(4 x)                = <force(x)>\n"})}),"\n",(0,t.jsx)(n.p,{children:"4 creates a pin. It forces recursive evaluation of x and wraps the result in a pin."}),"\n",(0,t.jsx)(n.h2,{id:"law-execution",children:"Law execution"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-unset",children:"(f:{n a b} x0..xn)   = EXEC([f x0..xn], b)  \n(f:<{n a b}> x0..xn) = EXEC([f x0..xn], b)\n"})}),"\n",(0,t.jsx)(n.p,{children:"Laws are executed by applying the EXEC function to an environment containing the law and its arguments, along with the law's body. This applies to both unpinned laws and pinned laws."}),"\n",(0,t.jsx)(n.p,{children:"The EXEC helper function uses an environment to execute law bodies, which are written in an embedded domain-specific language (EDSL). This EDSL is not a separate language per se, but rather a specific way of using PLAN constructs to represent law bodies \u2013 PLAN expressions that will have access to an environment of a specific size. Before going into EXEC, it is informative to look at the EDSL for law bodies in the abstract. It doesn\u2019t have a syntax, but if it did, it would look something like this:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-unset",children:"LawBody ::= Self                   -- self-reference\n          | Var Nat                -- var-reference (index into environment)\n          | Literal PLAN           -- produce literal value\n          | Apply LawBody LawBody  -- function application\n          | let LawBody in LawBody -- let binding (append to environment)\n"})}),"\n",(0,t.jsx)(n.p,{children:"These constructs are implemented by EXEC in the following way:"}),"\n",(0,t.jsx)(n.h4,{id:"references",children:(0,t.jsx)(n.em,{children:"References"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-unset",children:"EXEC(e, n:@) | n<len(e) = e[n]\n"})}),"\n",(0,t.jsx)(n.p,{children:"In law bodies, variables are referenced using indices instead of by name. 0 references the law itself, while all other valid indices reference the law\u2019s arguments. (Remember that before calling EXEC, we constructed the environment with the law at the head.) This corresponds to the Self and Var n constructs in the fake EDSL syntax."}),"\n",(0,t.jsx)(n.h4,{id:"function-application",children:(0,t.jsx)(n.em,{children:"Function application"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-unset",children:"EXEC(e, (0 x y))        = (EXEC(x) EXEC(y))\n"})}),"\n",(0,t.jsx)(n.p,{children:"The Apply construct is represented by 0. This continues to execute two law bodies, and applies the first to the second."}),"\n",(0,t.jsx)(n.h4,{id:"let-binding",children:(0,t.jsx)(n.em,{children:"Let-binding"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-unset",children:"EXEC(e, (1 v b))        = EXEC(f,b) where f = e ++ [EXEC(f,v)]\n"})}),"\n",(0,t.jsx)(n.p,{children:"Let-bindings are represented by 1. This creates a lazy binding \u2013 the value v is evaluated in an environment that includes the binding itself, allowing for cyclic data structures. The environment is extended with this new binding before evaluating the body b."}),"\n",(0,t.jsx)(n.h4,{id:"literals",children:(0,t.jsx)(n.em,{children:"Literals"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-unset",children:"EXEC(e, (2 x))          = x  \nEXEC(e, x)              = x\n"})}),"\n",(0,t.jsx)(n.p,{children:"A law body can produce a literal PLAN value, either deliberately using 2 or by default. These will always have been normalized during the creation of the law using opcode 0, and so will only reduce if they\u2019re further applied to something within the law body."}),"\n",(0,t.jsx)(n.h4,{id:"pin-application",children:"Pin application"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-unset",children:"(<i> ..)             = (i ..)\n"})}),"\n",(0,t.jsx)(n.p,{children:"If a pin is applied to an argument, that\u2019s the same thing as just applying the PLAN value inside the pin directly. This reflects the fact that formally, pins are simply magic boxes that contain normalized values."}),"\n",(0,t.jsx)(n.h2,{id:"evaluation-order",children:"Evaluation order"}),"\n",(0,t.jsx)(n.p,{children:"The informal PLAN specification contains these instructions:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-unset",children:"Treat this as a combinator system, and use normal-order evaluation to normalize.\nUnmatched patterns diverge.\n"})}),"\n",(0,t.jsx)(n.p,{children:"These are simply saying that PLAN evaluation is lazy, and that if we encounter a pattern that doesn\u2019t match any rules, then we should crash."}),"\n",(0,t.jsx)(n.h2,{id:"seed-deserialization",children:"Seed (de/serialization)"}),"\n",(0,t.jsxs)(n.p,{children:["Since we imagine Pallas as a natively networked database VM, we want to be able to write arbitrary PLAN values \u2013 including closures and suspended thunks \u2013 to disk, or send them over the network. Any PLAN value can be serialized to a nat using a format called ",(0,t.jsx)(n.strong,{children:"seed"}),", which is a simple format for encoding binary trees of natural numbers."]}),"\n",(0,t.jsx)(n.p,{children:"Seed has a number of desirable properties:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"It's very simple to write an efficient SEED loader. (See [this demo](TK TODO link) for an example of this)."}),"\n",(0,t.jsxs)(n.li,{children:["Naturals are stored word-aligned and word-padded. Multi-word nats can be loaded with zero copies by just storing big numbers as pointers into the input buffer. This is especially useful when working with files that are loaded with ",(0,t.jsx)(n.code,{children:"mmap()"})," and contain large binary blobs. In this situation, the host OS will transparently page this data in-and-out as necessary."]}),"\n",(0,t.jsx)(n.li,{children:"All repeated subtrees are written only once."}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:["Note again that PLAN trees encoded with seed can contain ",(0,t.jsx)(n.em,{children:"computations"}),", not just values. If this is undesirable, the decoder can just verify that everything it reads is in normal form."]}),"\n",(0,t.jsx)(n.h2,{id:"loot-disassembly",children:"Loot (disassembly)"}),"\n",(0,t.jsxs)(n.p,{children:["PLAN values can be disassembled and displayed in a human-readable form using the ",(0,t.jsx)(n.strong,{children:"loot"})," ",(0,t.jsx)(n.a,{href:"https://github.com/operating-function/pallas/blob/master/lib/Loot.hs",children:"algorithm"}),". For example, below is the disassembled PLAN of the foldr function, including all functions it has inlined into its body:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-unset",children:"* (_If a b c)=(2 c ((d e & d) b) a)  \n* (_Not a)=(_If a 0 1)  \n* (_IsApp a)=(1:(b&0):(b c d & 0):(b c & 1):(b&0) a)  \n* (_Null a)=(_Not _IsApp-a)  \n* (_Cdr a)=(1:(b&b):(b c d & d):(b c & c):(b&0) a)  \n* (_Car a)=(1:(b&4):(b c d & 0-b-c):(b c & b):(b&0) a)  \n* (_Get a b)=(_If _Null-a 0 (2 _Cdr-a (_Get _Car-a) b))  \n* (id a)=a  \n* (_Dec a)=(2:0:id a)  \n* (_Seq a b)=(2 b ((c d & c) b) a)  \n*   = (_Len a)  \n    ^ a  \n    : (go b c ? _Seq b (_If _Null-c b (go 3-b _Car-c)))  \n    : 0  \n*   = (foldr a b c)  \n    ^ a c b 0 _Len-c  \n    ? (go d e f g h)  \n    (_If h (d _Get-e-g (go d e f 3-g _Dec-h)) f)\n"})})]})}function h(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(c,{...e})}):c(e)}},8453:(e,n,a)=>{a.d(n,{R:()=>s,x:()=>o});var t=a(6540);const i={},l=t.createContext(i);function s(e){const n=t.useContext(l);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:s(e.components),t.createElement(l.Provider,{value:n},e.children)}}}]);