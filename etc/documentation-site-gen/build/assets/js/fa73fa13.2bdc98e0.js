"use strict";(self.webpackChunkpallas=self.webpackChunkpallas||[]).push([[129],{1031:(e,a,t)=>{t.r(a),t.d(a,{assets:()=>l,contentTitle:()=>o,default:()=>d,frontMatter:()=>i,metadata:()=>r,toc:()=>c});var n=t(4848),s=t(8453);const i={sidebar_position:2,id:"plan-data-model",title:"Data Model"},o=void 0,r={id:"explanation/plan-data-model",title:"Data Model",description:"PLAN Data model",source:"@site/../../doc/explanation/02.5_PLAN-the-data-model.md",sourceDirName:"explanation",slug:"/explanation/plan-data-model",permalink:"/docs/explanation/plan-data-model",draft:!1,unlisted:!1,editUrl:"https://github.com/operating-function/pallas/edit/main/doc/../../doc/explanation/02.5_PLAN-the-data-model.md",tags:[],version:"current",sidebarPosition:2,frontMatter:{sidebar_position:2,id:"plan-data-model",title:"Data Model"},sidebar:"explanationSidebar",previous:{title:"PLAN",permalink:"/docs/explanation/plan"},next:{title:"Evaluation Model",permalink:"/docs/explanation/plan-evaluation-model"}},l={},c=[{value:"PLAN Data model",id:"plan-data-model",level:2},{value:"Pins",id:"pins",level:2},{value:"Laws",id:"laws",level:2},{value:"Apps",id:"apps",level:2},{value:"Nats",id:"nats",level:2}];function h(e){const a={a:"a",admonition:"admonition",code:"code",em:"em",h2:"h2",li:"li",p:"p",strong:"strong",ul:"ul",...(0,s.R)(),...e.components};return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)(a.h2,{id:"plan-data-model",children:"PLAN Data model"}),"\n",(0,n.jsx)(a.p,{children:"PLAN\u2019s data model is specified abstractly as:"}),"\n",(0,n.jsx)(a.p,{children:(0,n.jsx)(a.code,{children:"Each value is a pin x:<i>, a law x:{n a b}, an app x:(f g), or a nat x:@."})}),"\n",(0,n.jsx)(a.p,{children:"These four constructs are what give PLAN its name, and they abstractly represent the following data structure:"}),"\n",(0,n.jsx)(a.p,{children:"Every PLAN expression is a heap that consists of a merkle-DAG of subheaps. Every subheap is a tree structure containing absolutely pure n-ary functions, closures, natural numbers, and pointers to other subheaps. We represent our heap as a merkle-DAG because its hash-based nature gives us pointers that remain stable between VM runs, allowing us to support huge heaps by transparently paging subheaps in and out from disk. This allows users to e.g. keep their whole media library \u201cin memory\u201d."}),"\n",(0,n.jsx)(a.admonition,{title:"TODO",type:"warning",children:(0,n.jsx)(a.p,{children:"Diagram forthcoming"})}),"\n",(0,n.jsx)(a.p,{children:"There\u2019s a lot to unpack in that description, so let\u2019s go through the four constructs one by one."}),"\n",(0,n.jsx)(a.h2,{id:"pins",children:"Pins"}),"\n",(0,n.jsx)(a.p,{children:(0,n.jsx)(a.strong,{children:"Subheaps: content addressed DAG nodes and contiguous memory regions of normalized values"})}),"\n",(0,n.jsxs)(a.p,{children:["Pins are heaps, and nodes in the merkle-DAG of heaps. Formally, a pin ",(0,n.jsx)(a.code,{children:"<i>"})," is just a magic box that contains another PLAN value ",(0,n.jsx)(a.code,{children:"i"})," that is guaranteed to have been normalized. In practice, a pin is a hint to the virtual machine that it should hash and deduplicate i, and store it in a contiguous region in memory and on disk, similar to ",(0,n.jsx)(a.a,{href:"https://harpocrates.github.io/ghc-head-libraries/ghc-compact/GHC-Compact.html",children:"GHC\u2019s Compact regions"}),". This gives us several nice properties:"]}),"\n",(0,n.jsxs)(a.ul,{children:["\n",(0,n.jsx)(a.li,{children:"Comparing two pins for equality is a constant-time operation, similar to when e.g. a string has been interned."}),"\n",(0,n.jsx)(a.li,{children:"Data access inside a pin is fast, since contiguous memory regions are cache-friendly."}),"\n",(0,n.jsx)(a.li,{children:"On disk and over the network, pins can be addressed by their hashes, which allows them to be loaded on demand, making the heap stable between runs. In this way they are similar to memory pages that might reference each other, but since pins are always normalized, these references are acyclic."}),"\n",(0,n.jsxs)(a.li,{children:["PLAN values are immutable, so we need to reclaim memory somehow. Garbage collection requires a full heap-traversal, which is a problem with the huge heaps that we want to support. Pins mitigate this problem because each one is stored in a contiguous region on disk, which means that pins on disk only ever reference other pins, not values ",(0,n.jsx)(a.em,{children:"inside"})," other pins. Because of this, a full garbage collection pass only needs to traverse the pin DAG, without looking at the data inside the pins. PLAN evaluation is lazy, but each state-machine transition does a full normalization, so long-lived space leaks are impossible, and the on-disk representation will never contain unevaluated thunks."]}),"\n"]}),"\n",(0,n.jsx)(a.h2,{id:"laws",children:"Laws"}),"\n",(0,n.jsx)(a.p,{children:(0,n.jsx)(a.strong,{children:"Supercombinators: pure n-ary functions"})}),"\n",(0,n.jsxs)(a.p,{children:["The law ",(0,n.jsx)(a.code,{children:"{n a b}"})," is a supercombinator of arbitrary but fixed arity a, with the body b and the name n. \u201c",(0,n.jsx)(a.a,{href:"https://wiki.haskell.org/Super_combinator",children:"Supercombinator"}),"\u201d really just means \u201can ",(0,n.jsx)(a.em,{children:"actually"})," pure function (or a constant)\u201d. Even in supposedly pure programming languages, functions can typically call other functions that are \u201cin scope\u201d, which means that they can access implicit state \u2013 a very reasonable UX affordance. But PLAN is not a UI, it is a specification, so we can\u2019t tolerate such ambiguity. To make a law accessible to another law, it must either be inlined or passed as an argument. This is what we mean when we say that laws are ",(0,n.jsx)(a.em,{children:"actually"})," pure functions. The only environment a law has access to is itself and its arguments."]}),"\n",(0,n.jsx)(a.h2,{id:"apps",children:"Apps"}),"\n",(0,n.jsx)(a.p,{children:(0,n.jsx)(a.strong,{children:"Applications: closures or thunks"})}),"\n",(0,n.jsx)(a.p,{children:"Apps are applications of functions to arguments. They are binary trees or cons cells that are often left-heavy or left-skewed, such as (((f a) b) c). Syntactically they associate to the left, so we can also write (f a b c). As the variable names suggest, the leftmost node in an app is typically a function, while the rest are arguments to that function, some of which might be other apps."}),"\n",(0,n.jsxs)(a.p,{children:["A partially applied function, such as ",(0,n.jsx)(a.code,{children:'({"fun" 2 body} arg1)'})," is a closure (notice the arity is 2), while a fully applied function such as ",(0,n.jsx)(a.code,{children:'({"fun" 2 body} arg1 arg2)'})," is a thunk. Apps that are closures can be deconstructed and inspected, but once an app has graduated to a thunk, it will be reduced before it can be further manipulated."]}),"\n",(0,n.jsxs)(a.p,{children:["Since all functions are ",(0,n.jsx)(a.em,{children:"actually"})," pure, a thunk-app contains the entire environment needed to execute a function. Because apps are used as environments in this way, the interpreter typically improves memory locality by recognizing their left-associativity and optimizing them to arrays, instead of storing the formal tree structure."]}),"\n",(0,n.jsx)(a.h2,{id:"nats",children:"Nats"}),"\n",(0,n.jsx)(a.p,{children:(0,n.jsx)(a.strong,{children:"Natural numbers: opaque data or opcodes"})}),"\n",(0,n.jsx)(a.p,{children:"Nats are natural numbers. Most of the time this is just data. We encode integers, strings and MP3 files using natural numbers. Nats that are smaller than the machine\u2019s word size get stored directly. Bigger nats are stored as pointers and benefit from structural sharing. The nats 0-4 can also code for opcodes: instructions to the virtual machine. Like laws, these operations are pure functions, but they are built in."})]})}function d(e={}){const{wrapper:a}={...(0,s.R)(),...e.components};return a?(0,n.jsx)(a,{...e,children:(0,n.jsx)(h,{...e})}):h(e)}},8453:(e,a,t)=>{t.d(a,{R:()=>o,x:()=>r});var n=t(6540);const s={},i=n.createContext(s);function o(e){const a=n.useContext(i);return n.useMemo((function(){return"function"==typeof e?e(a):{...a,...e}}),[a,e])}function r(e){let a;return a=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:o(e.components),n.createElement(i.Provider,{value:a},e.children)}}}]);