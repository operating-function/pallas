"use strict";(self.webpackChunkpallas=self.webpackChunkpallas||[]).push([[607],{2686:(e,n,a)=>{a.r(n),a.d(n,{assets:()=>l,contentTitle:()=>o,default:()=>h,frontMatter:()=>s,metadata:()=>r,toc:()=>c});var t=a(4848),i=a(8453);const s={sidebar_position:2,id:"plan-data-model",title:"Data Model"},o="PLAN",r={id:"explanation/plan-data-model",title:"Data Model",description:"The previous section provided an overview of the system and how the different components contribute to its overall functioning. Let\u2019s now take a closer look at each component, starting with PLAN.",source:"@site/../../doc/explanation/02_PLAN-the-data-model.md",sourceDirName:"explanation",slug:"/explanation/plan-data-model",permalink:"/docs/explanation/plan-data-model",draft:!1,unlisted:!1,editUrl:"https://github.com/operating-function/pallas/edit/main/doc/../../doc/explanation/02_PLAN-the-data-model.md",tags:[],version:"current",sidebarPosition:2,frontMatter:{sidebar_position:2,id:"plan-data-model",title:"Data Model"},sidebar:"explanationSidebar",previous:{title:"System Overview",permalink:"/docs/explanation/system-overview"},next:{title:"Evaluation Model",permalink:"/docs/explanation/plan-evaluation-model"}},l={},c=[{value:"Data model",id:"data-model",level:2},{value:"Pins",id:"pins",level:2},{value:"Laws",id:"laws",level:2},{value:"Apps",id:"apps",level:2},{value:"Nats",id:"nats",level:2}];function d(e){const n={a:"a",admonition:"admonition",code:"code",em:"em",h1:"h1",h2:"h2",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,i.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.p,{children:"The previous section provided an overview of the system and how the different components contribute to its overall functioning. Let\u2019s now take a closer look at each component, starting with PLAN."}),"\n",(0,t.jsx)(n.header,{children:(0,t.jsx)(n.h1,{id:"plan",children:"PLAN"})}),"\n",(0,t.jsx)(n.p,{children:"Nearly every core innovation of Pallas emerges from the design of PLAN. PLAN is the \u201cbytecode\u201d of Pallas, but in contrast to bytecode, it is human readable. It is a Turing-complete evaluation model which is purely functional, lazy and reflective. It is designed to strike a reasonable balance between several different design requirements:"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Human Readability"}),': Unlike typical low-level formats, PLAN maintains a degree of readability that allows developers to inspect and understand "binaries" directly.']}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Functional Compile Target"}),": PLAN serves as an excellent target for functional language compilers."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Efficient Memory Representation"}),": The structure of PLAN is designed to map well to in-memory data structures, allowing for efficient execution."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Database Oriented"}),": PLAN is purpose-built for personal databases, offering a \u201csingle-level store\u201d."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Ease of Implementation"}),": PLAN is possible to implement efficiently in a few thousand lines of code."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Extensibility and Modifiability"}),": PLAN allows programs to both construct new programs and inspect existing ones \u2013 including themselves. This allows them to upgrade and extend themselves, effectively running forever."]}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"It's not necessary to understand PLAN to program Pallas, but if you understand PLAN, you'll understand at least half of the system. Here is an informal pseudocode specification of PLAN, followed by an explanation:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-unset",children:"Each value is a pin x:<i>, a law x:{n a b}, an app x:(f g), or a nat x:@.\n\nTreat this as a combinator system, and use normal-order evaluation to normalize.\nUnmatched patterns diverge.\n\n    (0 n a b) | NAT(a)>0 = {NAT(n) NAT(a) force(b)}  \n    (1 p _ _ _ <x>)      = (p x)  \n    (1 _ l _ _ {n a b})  = (l n a b)  \n    (1 _ _ a _ (f x))    = (a f x)  \n    (1 _ _ _ n x:@)      = (n x)  \n    (2 z p x)            = n=NAT(x); if n=0 then z else p (n-1)  \n    (3 x)                = NAT(x)+1  \n    (4 x)                = <force(x)>  \n    (f:{n a b} x0..xn)   = EXEC([f x0..xn], b)  \n    (f:<{n a b}> x0..xn) = EXEC([f x0..xn], b)  \n    (<i> ..)             = (i ..)\n\n    NAT(x:@) = x  \n    NAT(_)   = 0\n\n    EXEC(e, n:@) | n<len(e) = e[n]  \n    EXEC(e, (0 x y))        = (EXEC(x) EXEC(y))  \n    EXEC(e, (1 v b))        = EXEC(f,b) where f = e ++ [EXEC(f,v)]  \n    EXEC(e, (2 x))          = x  \n    EXEC(e, x)              = x\n"})}),"\n",(0,t.jsx)(n.p,{children:"This informal specification glosses over some details regarding evaluation order and normalization, but is otherwise correct. For a more detailed and implementation-oriented specification, see the [reference](TK TODO link)."}),"\n",(0,t.jsx)(n.p,{children:"To start, we can note that the specification contains three things: at the top there\u2019s a data model, which is then followed by a few informal instructions and finally a number of rewrites over the data model. We\u2019ll go through the data model, then the rewrite rules, and finally the informal instructions."}),"\n",(0,t.jsx)(n.h2,{id:"data-model",children:"Data model"}),"\n",(0,t.jsx)(n.p,{children:"PLAN\u2019s data model is specified abstractly as:"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.code,{children:"Each value is a pin x:<i>, a law x:{n a b}, an app x:(f g), or a nat x:@."})}),"\n",(0,t.jsx)(n.p,{children:"These four constructs are what give PLAN its name, and they abstractly represent the following data structure:"}),"\n",(0,t.jsx)(n.p,{children:"Every PLAN expression is a heap that consists of a merkle-DAG of subheaps. Every subheap is a tree structure containing absolutely pure n-ary functions, closures, natural numbers, and pointers to other subheaps. We represent our heap as a merkle-DAG because its hash-based nature gives us pointers that remain stable between VM runs, allowing us to support huge heaps by transparently paging subheaps in and out from disk. This allows users to e.g. keep their whole media library \u201cin memory\u201d."}),"\n",(0,t.jsx)(n.admonition,{title:"TODO",type:"warning",children:(0,t.jsx)(n.p,{children:"Diagram forthcoming"})}),"\n",(0,t.jsx)(n.p,{children:"There\u2019s a lot to unpack in that description, so let\u2019s go through the four constructs one by one."}),"\n",(0,t.jsx)(n.h2,{id:"pins",children:"Pins"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Subheaps: content addressed DAG nodes and contiguous memory regions of normalized values"})}),"\n",(0,t.jsxs)(n.p,{children:["Pins are heaps, and nodes in the merkle-DAG of heaps. Formally, a pin ",(0,t.jsx)(n.code,{children:"<i>"})," is just a magic box that contains another PLAN value ",(0,t.jsx)(n.code,{children:"i"})," that is guaranteed to have been normalized. In practice, a pin is a hint to the virtual machine that it should hash and deduplicate i, and store it in a contiguous region in memory and on disk, similar to ",(0,t.jsx)(n.a,{href:"https://harpocrates.github.io/ghc-head-libraries/ghc-compact/GHC-Compact.html",children:"GHC\u2019s Compact regions"}),". This gives us several nice properties:"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:"Comparing two pins for equality is a constant-time operation, similar to when e.g. a string has been interned."}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:"Data access inside a pin is fast, since contiguous memory regions are cache-friendly."}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:"On disk and over the network, pins can be addressed by their hashes, which allows them to be loaded on demand, making the heap stable between runs. In this way they are similar to memory pages that might reference each other, but since pins are always normalized, these references are acyclic."}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:["PLAN values are immutable, so we need to reclaim memory somehow. Garbage collection requires a full heap-traversal, which is a problem with the huge heaps that we want to support. Pins mitigate this problem because each one is stored in a contiguous region on disk, which means that pins on disk only ever reference other pins, not values ",(0,t.jsx)(n.em,{children:"inside"})," other pins. Because of this, a full garbage collection pass only needs to traverse the pin DAG, without looking at the data inside the pins. PLAN evaluation is lazy, but each state-machine transition does a full normalization, so long-lived space leaks are impossible, and the on-disk representation will never contain unevaluated thunks."]}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"laws",children:"Laws"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Supercombinators: pure n-ary functions"})}),"\n",(0,t.jsxs)(n.p,{children:["The law ",(0,t.jsx)(n.code,{children:"{n a b}"})," is a supercombinator of arbitrary but fixed arity a, with the body b and the name n. \u201c",(0,t.jsx)(n.a,{href:"https://wiki.haskell.org/Super_combinator",children:"Supercombinator"}),"\u201d really just means \u201can ",(0,t.jsx)(n.em,{children:"actually"})," pure function (or a constant)\u201d. Even in supposedly pure programming languages, functions can typically call other functions that are \u201cin scope\u201d, which means that they can access implicit state \u2013 a very reasonable UX affordance. But PLAN is not a UI, it is a specification, so we can\u2019t tolerate such ambiguity. To make a law accessible to another law, it must either be inlined or passed as an argument. This is what we mean when we say that laws are ",(0,t.jsx)(n.em,{children:"actually"})," pure functions. The only environment a law has access to is itself and its arguments."]}),"\n",(0,t.jsx)(n.h2,{id:"apps",children:"Apps"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Applications: closures or thunks"})}),"\n",(0,t.jsx)(n.p,{children:"Apps are applications of functions to arguments. They are binary trees or cons cells that are often left-heavy or left-skewed, such as (((f a) b) c). Syntactically they associate to the left, so we can also write (f a b c). As the variable names suggest, the leftmost node in an app is typically a function, while the rest are arguments to that function, some of which might be other apps."}),"\n",(0,t.jsxs)(n.p,{children:["A partially applied function, such as ",(0,t.jsx)(n.code,{children:'({"fun" 2 body} arg1)'})," is a closure (notice the arity is 2), while a fully applied function such as ",(0,t.jsx)(n.code,{children:'({"fun" 2 body} arg1 arg2)'})," is a thunk. Apps that are closures can be deconstructed and inspected, but once an app has graduated to a thunk, it will be reduced before it can be further manipulated."]}),"\n",(0,t.jsxs)(n.p,{children:["Since all functions are ",(0,t.jsx)(n.em,{children:"actually"})," pure, a thunk-app contains the entire environment needed to execute a function. Because apps are used as environments in this way, the interpreter typically improves memory locality by recognizing their left-associativity and optimizing them to arrays, instead of storing the formal tree structure."]}),"\n",(0,t.jsx)(n.h2,{id:"nats",children:"Nats"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Natural numbers: opaque data or opcodes"})}),"\n",(0,t.jsx)(n.p,{children:"Nats are natural numbers. Most of the time this is just data. We encode integers, strings and MP3 files using natural numbers. Nats that are smaller than the machine\u2019s word size get stored directly. Bigger nats are stored as pointers and benefit from structural sharing. The nats 0-4 can also code for opcodes: instructions to the virtual machine. Like laws, these operations are pure functions, but they are built in."})]})}function h(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(d,{...e})}):d(e)}},8453:(e,n,a)=>{a.d(n,{R:()=>o,x:()=>r});var t=a(6540);const i={},s=t.createContext(i);function o(e){const n=t.useContext(s);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function r(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:o(e.components),t.createElement(s.Provider,{value:n},e.children)}}}]);