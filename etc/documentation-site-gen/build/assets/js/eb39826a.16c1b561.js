"use strict";(self.webpackChunkpallas=self.webpackChunkpallas||[]).push([[79],{8708:(e,a,n)=>{n.r(a),n.d(a,{assets:()=>s,contentTitle:()=>i,default:()=>o,frontMatter:()=>t,metadata:()=>r,toc:()=>l});var d=n(4848),p=n(8453);const t={},i="Pads",r={id:"reference/standard-library/pads",title:"Pads",description:"Pads are bit-strings encoded as non-zero natural numbers. Pads are not data-jetted, since the direct nat works perfectly. Pads are encoded least-significant-bit-first, with the high bit used to indicate the end of the bit-array.",source:"@site/../../doc/reference/standard-library/11_pads.md",sourceDirName:"reference/standard-library",slug:"/reference/standard-library/pads",permalink:"/reference/standard-library/pads",draft:!1,unlisted:!1,editUrl:"https://github.com/operating-function/pallas/edit/main/doc/../../doc/reference/standard-library/11_pads.md",tags:[],version:"current",sidebarPosition:11,frontMatter:{},sidebar:"referenceSidebar",previous:{title:"KV Tables",permalink:"/reference/standard-library/kv-tables"},next:{title:"Bars (byte arrays)",permalink:"/reference/standard-library/bars-byte-arrays"}},s={},l=[{value:"emptyPad",id:"emptypad",level:3},{value:"toPad",id:"topad",level:3},{value:"padNat",id:"padnat",level:3},{value:"natPad",id:"natpad",level:3},{value:"padLen",id:"padlen",level:3},{value:"padWeld",id:"padweld",level:3},{value:"padCat",id:"padcat",level:3},{value:"padFlat",id:"padflat",level:3},{value:"padSplitAt",id:"padsplitat",level:3},{value:"padIdx",id:"padidx",level:3},{value:"padGet",id:"padget",level:3},{value:"padSet",id:"padset",level:3},{value:"padMapWithKey",id:"padmapwithkey",level:3},{value:"padMap",id:"padmap",level:3},{value:"padComplement",id:"padcomplement",level:3},{value:"showPadStr",id:"showpadstr",level:3},{value:"showPadLit",id:"showpadlit",level:3}];function c(e){const a={admonition:"admonition",code:"code",h1:"h1",h3:"h3",header:"header",p:"p",pre:"pre",...(0,p.R)(),...e.components};return(0,d.jsxs)(d.Fragment,{children:[(0,d.jsx)(a.header,{children:(0,d.jsx)(a.h1,{id:"pads",children:"Pads"})}),"\n",(0,d.jsx)(a.p,{children:"Pads are bit-strings encoded as non-zero natural numbers. Pads are not data-jetted, since the direct nat works perfectly. Pads are encoded least-significant-bit-first, with the high bit used to indicate the end of the bit-array."}),"\n",(0,d.jsx)(a.pre,{children:(0,d.jsx)(a.code,{children:"p#{}          == 0b1 ; 1\np#{00}        == 0b100 ; 4\np#{01}        == 0b110 ; 6\np#{111000}    == 0b1000111 ; %G\n"})}),"\n",(0,d.jsx)(a.p,{children:"All of the pad operations coerce their inputs into pads, and always return pads."}),"\n",(0,d.jsx)(a.admonition,{type:"info",children:(0,d.jsxs)(a.p,{children:["The REPL will print pads as their natural number representation by default. Use ",(0,d.jsx)(a.code,{children:"padShowLit"})," to coerce the output into the bit-string format used here."]})}),"\n",(0,d.jsx)(a.h3,{id:"emptypad",children:"emptyPad"}),"\n",(0,d.jsx)(a.p,{children:"Represents an empty pad."}),"\n",(0,d.jsx)(a.pre,{children:(0,d.jsx)(a.code,{className:"language-sire",children:"emptyPad    == 1\n"})}),"\n",(0,d.jsx)(a.h3,{id:"topad",children:"toPad"}),"\n",(0,d.jsx)(a.p,{children:"Coerces a value into a non-zero natural number (pad)."}),"\n",(0,d.jsx)(a.pre,{children:(0,d.jsx)(a.code,{className:"language-sire",children:"toPad 0     == 1\ntoPad 1     == 1\ntoPad 3     == 3\n"})}),"\n",(0,d.jsx)(a.h3,{id:"padnat",children:"padNat"}),"\n",(0,d.jsx)(a.p,{children:"Converts a pad to a natural number, dropping all trailing zeros."}),"\n",(0,d.jsx)(a.pre,{children:(0,d.jsx)(a.code,{className:"language-sire",children:"padNat p#0      == 0\npadNat p#1      == 1\npadNat p#100    == 1\n"})}),"\n",(0,d.jsx)(a.h3,{id:"natpad",children:"natPad"}),"\n",(0,d.jsx)(a.p,{children:"Converts a natural number into a pad with a specific minimum bit-width."}),"\n",(0,d.jsx)(a.pre,{children:(0,d.jsx)(a.code,{className:"language-sire",children:"natPad 1 3    == p#100\nnatPad 2 4    == p#0100\nnatPad 3 2    == p#11\n"})}),"\n",(0,d.jsx)(a.h3,{id:"padlen",children:"padLen"}),"\n",(0,d.jsx)(a.p,{children:"Returns the length of a pad (number of bits)."}),"\n",(0,d.jsx)(a.pre,{children:(0,d.jsx)(a.code,{className:"language-sire",children:"padLen p#0       == 1\npadLen p#1       == 1\npadLen p#1010    == 4\n"})}),"\n",(0,d.jsx)(a.h3,{id:"padweld",children:"padWeld"}),"\n",(0,d.jsx)(a.p,{children:"Concatenates two pads."}),"\n",(0,d.jsx)(a.pre,{children:(0,d.jsx)(a.code,{className:"language-sire",children:"padWeld p#10 p#11      == p#1011\npadWeld p#0 p#1        == p#01\npadWeld p#111 p#000    == p#111000\n"})}),"\n",(0,d.jsx)(a.h3,{id:"padcat",children:"padCat"}),"\n",(0,d.jsx)(a.p,{children:"Concatenates a row of pads."}),"\n",(0,d.jsx)(a.pre,{children:(0,d.jsx)(a.code,{className:"language-sire",children:"padCat [p#1 p#0 p#11]    == p#1011\npadCat [p#10 p#01]       == p#1001\npadCat []                == p#{}\n"})}),"\n",(0,d.jsx)(a.h3,{id:"padflat",children:"padFlat"}),"\n",(0,d.jsx)(a.p,{children:"Flattens and concatenates a nested structure of pads."}),"\n",(0,d.jsx)(a.pre,{children:(0,d.jsx)(a.code,{className:"language-sire",children:"padFlat [[p#1 p#0] [p#1 p#1]]    == p#1011\npadFlat [p#10 p#11]              == p#1011\npadFlat [[[]] []]                == p#{}\n"})}),"\n",(0,d.jsx)(a.h3,{id:"padsplitat",children:"padSplitAt"}),"\n",(0,d.jsx)(a.p,{children:"Splits a pad at a given index."}),"\n",(0,d.jsx)(a.pre,{children:(0,d.jsx)(a.code,{className:"language-sire",children:"padSplitAt 2 p#1111    == [p#11 p#11]\npadSplitAt 1 p#1010    == [p#1 p#010]\npadSplitAt 3 p#1001    == [p#100 p#1]\n"})}),"\n",(0,d.jsx)(a.h3,{id:"padidx",children:"padIdx"}),"\n",(0,d.jsx)(a.p,{children:"Returns the nth bit from a pad."}),"\n",(0,d.jsx)(a.pre,{children:(0,d.jsx)(a.code,{className:"language-sire",children:"padIdx 0 p#1010    == 1\npadIdx 1 p#1010    == 0\npadIdx 3 p#1010    == 0\n"})}),"\n",(0,d.jsx)(a.h3,{id:"padget",children:"padGet"}),"\n",(0,d.jsx)(a.p,{children:"Alias for padIdx, but with arguments flipped."}),"\n",(0,d.jsx)(a.pre,{children:(0,d.jsx)(a.code,{className:"language-sire",children:"padGet p#1010 0    == 1\npadGet p#1010 1    == 0\npadGet p#1010 3    == 0\n"})}),"\n",(0,d.jsx)(a.h3,{id:"padset",children:"padSet"}),"\n",(0,d.jsx)(a.p,{children:"Sets the nth bit in a pad using a Bit."}),"\n",(0,d.jsx)(a.pre,{children:(0,d.jsx)(a.code,{className:"language-sire",children:"padSet p#0000 2 1    == p#0010\npadSet p#1111 1 0    == p#1011\npadSet p#1010 3 1    == p#1011\n"})}),"\n",(0,d.jsx)(a.h3,{id:"padmapwithkey",children:"padMapWithKey"}),"\n",(0,d.jsx)(a.p,{children:"Maps a function over the bits in a pad, providing both the index and the bit value."}),"\n",(0,d.jsx)(a.pre,{children:(0,d.jsx)(a.code,{className:"language-sire",children:"padMapWithKey (k b & if even-k b not-b) p#0000    == p#0101\npadMapWithKey (k b & if even-k b not-b) p#1111    == p#1010\npadMapWithKey (k b & add k b) p#1010              == p#1111\n"})}),"\n",(0,d.jsx)(a.h3,{id:"padmap",children:"padMap"}),"\n",(0,d.jsx)(a.p,{children:"Maps a function over the bits in a pad, coercing outputs to bits."}),"\n",(0,d.jsx)(a.pre,{children:(0,d.jsx)(a.code,{className:"language-sire",children:"padMap not p#1010          == p#0101\npadMap (add 1) p#1010      == p#1111\npadMap (const 0) p#1111    == p#0000\n"})}),"\n",(0,d.jsx)(a.h3,{id:"padcomplement",children:"padComplement"}),"\n",(0,d.jsx)(a.p,{children:"Complements all bits in a pad."}),"\n",(0,d.jsx)(a.pre,{children:(0,d.jsx)(a.code,{className:"language-sire",children:"padComplement p#1010    == p#0101\npadComplement p#1111    == p#0000\npadComplement p#0000    == p#1111\n"})}),"\n",(0,d.jsx)(a.h3,{id:"showpadstr",children:"showPadStr"}),"\n",(0,d.jsx)(a.p,{children:"Converts a pad to its string representation."}),"\n",(0,d.jsx)(a.pre,{children:(0,d.jsx)(a.code,{className:"language-sire",children:"showPadStr p#1010    == {0101}\nshowPadStr p#1000    == {0001}\nshowPadStr p#{}      == 0\n"})}),"\n",(0,d.jsx)(a.h3,{id:"showpadlit",children:"showPadLit"}),"\n",(0,d.jsx)(a.p,{children:"Converts a pad to its Rex literal representation."}),"\n",(0,d.jsx)(a.pre,{children:(0,d.jsx)(a.code,{className:"language-sire",children:"showPadLit p#1010    == p#0101\nshowPadLit p#1000    == p#0001\nshowPadLit p#{}      == p#{}\n"})})]})}function o(e={}){const{wrapper:a}={...(0,p.R)(),...e.components};return a?(0,d.jsx)(a,{...e,children:(0,d.jsx)(c,{...e})}):c(e)}},8453:(e,a,n)=>{n.d(a,{R:()=>i,x:()=>r});var d=n(6540);const p={},t=d.createContext(p);function i(e){const a=d.useContext(t);return d.useMemo((function(){return"function"==typeof e?e(a):{...a,...e}}),[a,e])}function r(e){let a;return a=e.disableParentContext?"function"==typeof e.components?e.components(p):e.components||p:i(e.components),d.createElement(t.Provider,{value:a},e.children)}}}]);