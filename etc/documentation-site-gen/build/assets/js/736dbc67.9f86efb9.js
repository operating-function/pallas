"use strict";(self.webpackChunkpallas=self.webpackChunkpallas||[]).push([[331],{4948:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>o,default:()=>h,frontMatter:()=>r,metadata:()=>s,toc:()=>c});var a=n(4848),i=n(8453);const r={sidebar_position:4,id:"vm-and-interpreter",title:"VM and Interpreter"},o="VM and Interpreter",s={id:"explanation/vm-and-interpreter",title:"VM and Interpreter",description:"PLAN is a standard for representing compute and data in the abstract; a PLAN expression is a specification of a program. We need to be able to turn such specifications into actual hardware operations. This is the job of a PLAN interpreter. A PLAN interpreter implements PLAN.",source:"@site/../../doc/explanation/04_vm-and-interpreter.md",sourceDirName:"explanation",slug:"/explanation/vm-and-interpreter",permalink:"/docs/explanation/vm-and-interpreter",draft:!1,unlisted:!1,editUrl:"https://github.com/operating-function/pallas/edit/main/doc/../../doc/explanation/04_vm-and-interpreter.md",tags:[],version:"current",sidebarPosition:4,frontMatter:{sidebar_position:4,id:"vm-and-interpreter",title:"VM and Interpreter"},sidebar:"explanationSidebar",previous:{title:"Evaluation Model",permalink:"/docs/explanation/plan-evaluation-model"},next:{title:"Sire and Rex",permalink:"/docs/explanation/sire-and-rex"}},l={},c=[{value:"Interpreting PLAN",id:"interpreting-plan",level:2},{value:"Jets",id:"jets",level:3},{value:"Data jets",id:"data-jets",level:3},{value:"Manifests",id:"manifests",level:2},{value:"Cogs",id:"cogs",level:3},{value:"Drivers",id:"drivers",level:3},{value:"<em>Effects</em>",id:"effects",level:4},{value:"Jobs",id:"jobs",level:3}];function d(e){const t={a:"a",admonition:"admonition",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,i.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(t.header,{children:(0,a.jsx)(t.h1,{id:"vm-and-interpreter",children:"VM and Interpreter"})}),"\n",(0,a.jsx)(t.p,{children:"PLAN is a standard for representing compute and data in the abstract; a PLAN expression is a specification of a program. We need to be able to turn such specifications into actual hardware operations. This is the job of a PLAN interpreter. A PLAN interpreter implements PLAN."}),"\n",(0,a.jsx)(t.p,{children:"Additionally, since we\u2019re promising a concurrent and persisted virtual machine that should be able to affect the real world, we need a standard that tells us how to instantiate such a VM based on a PLAN manifest."}),"\n",(0,a.jsx)(t.p,{children:"Let\u2019s talk about interpreting PLAN first, then we\u2019ll move on to how manifests specify the operation of the VM."}),"\n",(0,a.jsx)(t.h2,{id:"interpreting-plan",children:"Interpreting PLAN"}),"\n",(0,a.jsxs)(t.p,{children:["While the [informal PLAN specification](TK TODO link) is shown in this explanation, the [formal specification](TK TODO link) is purposefully written in a very implementation-oriented form, to emphasize that this is a wholly practical system despite being so minimal. Most of the implementation falls out directly from that specification. However, some optimizations are necessary to make a PLAN interpreter practically useful. In the ",(0,a.jsx)(t.a,{href:"/docs/explanation/plan-data-model",children:"explanation of PLAN\u2019s data model"}),", we\u2019ve explained how the memory layout of pins and apps can be optimized and how the former helps with garbage collection, but we also need to consider jets and data jets."]}),"\n",(0,a.jsx)(t.h3,{id:"jets",children:"Jets"}),"\n",(0,a.jsx)(t.p,{children:"PLAN only has a single arithmetic operation: increment by one, also known as the opcode 3. This allows us to do anything we want in theory: we can implement addition as repeated increment, and multiplication as repeated addition, and so on. This works in principle, but not in practice."}),"\n",(0,a.jsxs)(t.p,{children:["The reason why PLAN doesn\u2019t have more than 5 opcodes is because it needs to be forward and backward compatible. Old code should work on new implementations, and new code should work on old implementations, so we can\u2019t add new opcodes to the standard. Because of this, we opt to express all operations using ",(0,a.jsx)(t.em,{children:"algorithms"})," instead of extending the evaluation model. If an operation turns out to be beneficial to optimize, the PLAN interpreter is free to do so by short-circuiting PLAN evaluation and instead performing the same operation some other way. We call such optimized functions ",(0,a.jsx)(t.strong,{children:"jets"}),", and they\u2019re similar to how a CPU might dispatch certain operations to a GPU \u2013 indeed, a jet could be used to replace a matrix multiplication algorithm with a direct hardware instruction."]}),"\n",(0,a.jsxs)(t.p,{children:["A jet is always a pinned law, ",(0,a.jsx)(t.code,{children:"<{n a b}>"}),". Since laws are how we store code, they are the only things that make sense to jet, but checking every law that we encounter against the interpreter\u2019s jet table would be expensive. Pins give us constant-time equality checks, so we immediately know whether a pinned law should be jetted or not."]}),"\n",(0,a.jsx)(t.p,{children:(0,a.jsx)(t.a,{href:"/docs/reference/vm-and-interpreter/jets-reference",children:"Jets reference and examples"})}),"\n",(0,a.jsx)(t.h3,{id:"data-jets",children:"Data jets"}),"\n",(0,a.jsxs)(t.p,{children:["Certain data structures are crucial for performant computation. In particular, computers love linear memory, so we need arrays. We solve this using something called ",(0,a.jsx)(t.strong,{children:"data jets"}),", which are simply irreducible PLAN expressions that the interpreter knows how to optimize in memory. For example, an array of length n is represented in PLAN using the following structure:"]}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-unset",children:"({0 n+1 0} x0 x1 \u2026 xn)\n"})}),"\n",(0,a.jsx)(t.p,{children:"There are a few things to note here:"}),"\n",(0,a.jsxs)(t.ul,{children:["\n",(0,a.jsx)(t.li,{children:"Since the law\u2019s arity is n+1, this app doesn\u2019t reduce. Formally, it\u2019s simply a closure that contains all the array elements."}),"\n",(0,a.jsx)(t.li,{children:"The law has the name 0, which is null in both ASCII and UTF-8, and so in most languages it will be an illegal name for everything except perhaps anonymous functions."}),"\n",(0,a.jsxs)(t.li,{children:["The body is ",(0,a.jsx)(t.code,{children:"0"}),", which means that the function immediately returns itself."]}),"\n"]}),"\n",(0,a.jsxs)(t.p,{children:["An anonymous function that ",(0,a.jsx)(t.em,{children:"only"})," returns itself is objectively useless, so we know that we'll never encounter this law in any other context. But we do need to check whether every new law we encounter matches this pattern. Fortunately, this only requires exactly three operations: ",(0,a.jsx)(t.code,{children:"(name==0 && body==0)"}),"."]}),"\n",(0,a.jsx)(t.h2,{id:"manifests",children:"Manifests"}),"\n",(0,a.jsxs)(t.p,{children:["While PLAN is a Turing-complete evaluation model, we don\u2019t just want to compute. We want to store data and perform actions in the real world. For this reason, we use PLAN to write a manifest that instructs a virtual machine how to do this. A manifest can be stored in many different but equivalent ways on disk, but in the end they all code for a PLAN expression that specifies something called a ",(0,a.jsx)(t.strong,{children:"cog"}),", which is responsible for keeping data and business logic intact and in sync. Among other things, a cog includes a set of ",(0,a.jsx)(t.strong,{children:"drivers"}),", which instruct the VM on how the cog needs to connect to the outside world. A driver could for example be a stateless HTTP server or an RTP video streamer."]}),"\n",(0,a.jsxs)(t.p,{children:["Both cogs and drivers are persisted and evolving pieces of code that will resume their operation if the VM is ever rebooted, moved, or upgraded. The difference is that after a VM reboot, a cog will resume from its ",(0,a.jsx)(t.em,{children:"latest"})," state, while a driver will resume from its ",(0,a.jsx)(t.em,{children:"initial"})," state. The initial states of all drivers are included in the cog\u2019s state; the cog tells the VM which drivers it requires in order to interact with the outside."]}),"\n",(0,a.jsx)(t.p,{children:"Both cogs and drivers are transition functions expressed in PLAN \u2013 closures that are ready to receive an input and will produce a new transition function as a result. Owing to their differences, cogs and drivers look slightly different from each other. We\u2019ll start by looking at cogs."}),"\n",(0,a.jsx)(t.h3,{id:"cogs",children:"Cogs"}),"\n",(0,a.jsx)(t.admonition,{title:"TODO",type:"warning",children:(0,a.jsx)(t.p,{children:"Diagram forthcoming"})}),"\n",(0,a.jsx)(t.p,{children:"Cogs are programs that run forever. Even if you reboot your machine, a cog will continue exactly where it left off. Cogs are important because both code and data are important. The traditional persistence solution is to do a complex orchestration involving some combination of a database and source code, configuration files and binaries on a filesystem, and hope that these will allow the machine to get back to the same state at a later time. Or not \u2013 \u201chave you tried turning it off and on again?\u201d implies that we often aren\u2019t able to achieve this. In contrast, cogs simply keep their state \u201cin memory\u201d and advance the entire system state transactionally."}),"\n",(0,a.jsx)(t.p,{children:"PLAN doesn\u2019t have types, and no mainstream languages have good notations for talking about closures that need to capture certain values. Conceptually though, the following pseudo-Haskell paints a reasonably clear picture of what the VM expects from a cog:"}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-haskell",children:"type Worker   = Driver | Job -- Jobs are explained below\ntype WorkerId = Nat  \ntype MsgId    = Nat  \ntype Input    = (WorkerId, PLAN)  \ntype Output   = (WorkerId, MsgId, PLAN)\n\ntype CogClosure =  \n    { run     :: CogClosure -> Array Input -> (CogClosure, Array Output)  \n    , state   :: state  \n    , query   :: WorkerID -> state -> PLAN -> PLAN  \n    , workers :: Array Worker  \n    }\n"})}),"\n",(0,a.jsx)(t.p,{children:"A cog is a closure that captures four values:"}),"\n",(0,a.jsxs)(t.ul,{children:["\n",(0,a.jsxs)(t.li,{children:[(0,a.jsx)(t.code,{children:"run"})," is a function that will be called by the VM as soon as it has any inputs to give to the cog. The first argument will always be the cog closure itself, and the second argument will be a batch of inputs. run will then return a tuple with a new cog closure and an array of outputs that the VM should give to drivers."]}),"\n",(0,a.jsxs)(t.li,{children:[(0,a.jsx)(t.code,{children:"state"})," is a state value that the cog makes available to its drivers for concurrent read-only queries."]}),"\n",(0,a.jsxs)(t.li,{children:[(0,a.jsx)(t.code,{children:"query"})," is a function that drivers are forced to use when querying the cog. It accepts the driver\u2019s worker ID, the cog\u2019s current state and a PLAN value that codes for a query. The ",(0,a.jsx)(t.code,{children:"query"})," function is allowed to interpret the PLAN value however it wants. It could even be code!"]}),"\n",(0,a.jsxs)(t.li,{children:[(0,a.jsx)(t.code,{children:"workers"})," is an array of drivers and parallel evaluation jobs that the VM will run on behalf of the cog. We haven\u2019t mentioned parallel evaluation jobs yet, we\u2019ll return to them after we\u2019ve explained drivers in more detail."]}),"\n"]}),"\n",(0,a.jsx)(t.p,{children:"The most important takeaway here is that the cog is free to change itself. It can even replace itself with a completely new value. This means that programs can upgrade themselves and effectively run forever."}),"\n",(0,a.jsx)(t.p,{children:"We\u2019ve said that the VM will persist the most recent state of the cog. If a cog grows large, writing its entire PLAN value to disk (or to a cloud server!) could be quite expensive. But because cogs are transition functions, we don\u2019t need to do that. We can simply write each batch of inputs to a log. If we need to get back to our latest state after a reboot, we can replay the log. Whenever the log grows large, we can write a snapshot of the current cog state, prune the log up until that point, and start writing a new log."}),"\n",(0,a.jsxs)(t.p,{children:["See the ",(0,a.jsx)(t.a,{href:"/docs/reference/vm-and-interpreter/cogs-reference",children:"cog reference"})," for a more detailed description of this process."]}),"\n",(0,a.jsx)(t.h3,{id:"drivers",children:"Drivers"}),"\n",(0,a.jsx)(t.admonition,{title:"TODO",type:"warning",children:(0,a.jsx)(t.p,{children:"Diagram forthcoming"})}),"\n",(0,a.jsx)(t.p,{children:"Drivers are programs that mediate the cog\u2019s interactions with the outside world. They allow the cog to tell the VM how and when it should perform actions beyond pure computations. Drivers are important to minimize disk writes in a predictable and portable way. A naive architecture might feed all incoming data to the cog, but since this would incur a high number of disk writes, in practice this architecture would force the VM to implement a poorly specified exoskeleton that sifts through incoming data and decides when something should get persisted. This would almost certainly vary between runtimes, and so those performance optimizations wouldn\u2019t be portable. In the extreme, certain network protocols that use many small packets to build up huge logical messages might only work on runtimes that are aware of these optimizations. We use drivers to ensure that we can optimize disk writes in a way that\u2019s actually portable."}),"\n",(0,a.jsx)(t.p,{children:"The cog puts drivers into its array of workers in order to instruct the VM how it should interact with the outside world. Drivers do not have automatically persisted states, but they do have states. They need this to be able to engage in stateful protocols such as sessions or handshakes, so that they can accumulate and assemble incoming data before submitting semantically meaningful units as inputs to the cog."}),"\n",(0,a.jsx)(t.p,{children:"The format for drivers closely resembles that of cogs, but is simpler. Again in Haskell:"}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-haskell",children:"type MsgId  = Nat  \ntype Effect = (MsgId, Eff a)\n\ntype Driver = Driver -> MsgId -> PLAN -> (Driver, Array Effect)\n"})}),"\n",(0,a.jsx)(t.p,{children:"Just as a cog, a driver is expected to produce a new driver and an array of outputs (here called effects, more on that in a bit). Just as a cog, the driver has access to the current version of itself when doing so, but unlike a cog, that doesn\u2019t have to be a closure that captures any additional values \u2013 hence the simpler structure. The driver is also only passed one input (accompanied by a message ID) at a time instead of a batch, which is cheap because driver inputs are never written to disk."}),"\n",(0,a.jsxs)(t.p,{children:["The simplest version of a driver is one that simply opens a connection to the outside world and always just forwards any incoming data to the cog as an input. No state is necessary for this, so drivers aren\u2019t required to capture any additional values in a closure the way that a cog does. But in practice, most drivers will close over some custom state, so that they can respond intelligently to incoming data. Most of the time, it\u2019s neither efficient nor useful to indiscriminately persist all incoming data, so most realistic drivers should implement ",(0,a.jsx)(t.em,{children:"protocols"})," such as HTTP, Telnet or RTP."]}),"\n",(0,a.jsxs)(t.p,{children:["See the ",(0,a.jsx)(t.a,{href:"/docs/reference/vm-and-interpreter/drivers-reference",children:"driver reference"})," for more information on the driver format."]}),"\n",(0,a.jsx)(t.h4,{id:"effects",children:(0,a.jsx)(t.em,{children:"Effects"})}),"\n",(0,a.jsx)(t.admonition,{title:"TODO",type:"warning",children:(0,a.jsx)(t.p,{children:"Diagram forthcoming"})}),"\n",(0,a.jsx)(t.p,{children:"Drivers can ask the VM to do three things: query the cog\u2019s current state, submit an input to the cog, and handle outside connections. They do this by emitting effects. Effects are simply arrays which contain the name of an effect together with some data. The runtime, or an in-system virtualization environment, will read this, perform some operation, and might inject an input back into the driver at a later time."}),"\n",(0,a.jsxs)(t.p,{children:["For now, the only interface that workers have to the outside world is TCP. UDP will be added in the future. You can do basically everything over these \u2013 for example the host machine\u2019s file system can be read and manipulated over TCP using an FTP driver. By limiting ourselves to proven network transports such as TCP and UDP, we can do everything within the system instead of having to continuously extend the runtime, thus maximizing forward compatibility and ",(0,a.jsx)(t.a,{href:"/docs/philosophy/philosopy-intro",children:"making it easy to support new architectures"}),"."]}),"\n",(0,a.jsx)(t.p,{children:"Of course, some things require lower latency than either TCP or UDP can offer, for example real-time audio or graphics. Eventually we\u2019ll have to add effects for such interfaces, but we expect these to be few and new ones to be very infrequent. We can\u2019t guarantee perfect forward compatibility, but we expect it to be very good in practice."}),"\n",(0,a.jsxs)(t.p,{children:["See the ",(0,a.jsx)(t.a,{href:"/docs/reference/vm-and-interpreter/effects-reference",children:"effect reference"})," for a list of all available effects."]}),"\n",(0,a.jsx)(t.h3,{id:"jobs",children:"Jobs"}),"\n",(0,a.jsxs)(t.p,{children:["When discussing the cog\u2019s array of workers, we mentioned that a worker can be either a driver or a parallel evaluation ",(0,a.jsx)(t.strong,{children:"job"}),". While drivers handle concurrency, jobs handle parallelism. A job is simply a PLAN expression that the cog asks the VM to evaluate. Once evaluation has crashed or completed, the result will be logged and injected as an input to the cog."]}),"\n",(0,a.jsxs)(t.p,{children:["See the ",(0,a.jsx)(t.a,{href:"/docs/reference/vm-and-interpreter/jobs-reference",children:"job reference"})," for more information."]})]})}function h(e={}){const{wrapper:t}={...(0,i.R)(),...e.components};return t?(0,a.jsx)(t,{...e,children:(0,a.jsx)(d,{...e})}):d(e)}},8453:(e,t,n)=>{n.d(t,{R:()=>o,x:()=>s});var a=n(6540);const i={},r=a.createContext(i);function o(e){const t=a.useContext(r);return a.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function s(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:o(e.components),a.createElement(r.Provider,{value:t},e.children)}}}]);