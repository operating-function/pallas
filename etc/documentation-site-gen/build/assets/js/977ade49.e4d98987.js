"use strict";(self.webpackChunkpallas=self.webpackChunkpallas||[]).push([[807],{7678:(e,a,n)=>{n.r(a),n.d(a,{assets:()=>b,contentTitle:()=>l,default:()=>h,frontMatter:()=>s,metadata:()=>r,toc:()=>d});var t=n(4848),i=n(8453);const s={},l="KV Tables",r={id:"reference/standard-library/kv-tables",title:"KV Tables",description:"Type signatures are provisional and may contain errors.",source:"@site/../../doc/reference/standard-library/10_kv-tables.md",sourceDirName:"reference/standard-library",slug:"/reference/standard-library/kv-tables",permalink:"/reference/standard-library/kv-tables",draft:!1,unlisted:!1,editUrl:"https://github.com/operating-function/pallas/edit/main/doc/../../doc/reference/standard-library/10_kv-tables.md",tags:[],version:"current",sidebarPosition:10,frontMatter:{},sidebar:"referenceSidebar",previous:{title:"Sets",permalink:"/reference/standard-library/sets"},next:{title:"Pads",permalink:"/reference/standard-library/pads"}},b={},d=[{value:"tabSing",id:"tabsing",level:3},{value:"isTab",id:"istab",level:3},{value:"tabSearchCase",id:"tabsearchcase",level:3},{value:"tabLen",id:"tablen",level:3},{value:"tabIdx",id:"tabidx",level:3},{value:"tabKeysSet",id:"tabkeysset",level:3},{value:"tabKeysRow",id:"tabkeysrow",level:3},{value:"tabKeysList",id:"tabkeyslist",level:3},{value:"tabHas",id:"tabhas",level:3},{value:"tabGet",id:"tabget",level:3},{value:"tabValsRow",id:"tabvalsrow",level:3},{value:"tabValsList",id:"tabvalslist",level:3},{value:"tabSwitch",id:"tabswitch",level:3},{value:"tabFromPairs",id:"tabfrompairs",level:3},{value:"tabFromAscPairs",id:"tabfromascpairs",level:3},{value:"tabToPairs",id:"tabtopairs",level:3},{value:"tabToPairList",id:"tabtopairlist",level:3},{value:"tabToList",id:"tabtolist",level:3},{value:"tabPut",id:"tabput",level:3},{value:"tabFromPairsList",id:"tabfrompairslist",level:3},{value:"tabIns",id:"tabins",level:3},{value:"tabIsEmpty",id:"tabisempty",level:3},{value:"tabDel",id:"tabdel",level:3},{value:"tabPop",id:"tabpop",level:3},{value:"tabSplitAt",id:"tabsplitat",level:3},{value:"tabSplitLT",id:"tabsplitlt",level:3},{value:"tabAlter",id:"tabalter",level:3},{value:"tabMapWithKey",id:"tabmapwithkey",level:3},{value:"tabMap",id:"tabmap",level:3},{value:"tabUnionWith",id:"tabunionwith",level:3},{value:"tabUnion",id:"tabunion",level:3},{value:"tabWeld",id:"tabweld",level:3},{value:"tabCatRow",id:"tabcatrow",level:3},{value:"tabLookup",id:"tablookup",level:3},{value:"tabMinKey",id:"tabminkey",level:3},{value:"tabFoldlWithKey",id:"tabfoldlwithkey",level:3},{value:"tabElemIdx",id:"tabelemidx",level:3},{value:"emptyTab",id:"emptytab",level:3},{value:"tabInsWith",id:"tabinswith",level:3},{value:"tabFilterWithKey",id:"tabfilterwithkey",level:3}];function c(e){const a={admonition:"admonition",code:"code",h1:"h1",h3:"h3",header:"header",p:"p",pre:"pre",...(0,i.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(a.header,{children:(0,t.jsx)(a.h1,{id:"kv-tables",children:"KV Tables"})}),"\n",(0,t.jsx)(a.admonition,{title:"TODO",type:"warning",children:(0,t.jsx)(a.p,{children:"Type signatures are provisional and may contain errors."})}),"\n",(0,t.jsx)(a.p,{children:"A tab is a data-jetted map from noun to noun."}),"\n",(0,t.jsx)(a.h3,{id:"tabsing",children:"tabSing"}),"\n",(0,t.jsx)(a.pre,{children:(0,t.jsx)(a.code,{children:"(tabSing key val)\n> key : a\n> val : b\n> Tab a\n"})}),"\n",(0,t.jsx)(a.p,{children:"Creates a singleton table with one key-value pair."}),"\n",(0,t.jsx)(a.pre,{children:(0,t.jsx)(a.code,{className:"language-sire",children:"tabSing 1 2        == [1=2]\ntabSing {a} {b}    == [a=(%b)]\ntabSing 0 []       == [0=[]]\n"})}),"\n",(0,t.jsx)(a.h3,{id:"istab",children:"isTab"}),"\n",(0,t.jsx)(a.pre,{children:(0,t.jsx)(a.code,{children:"(isTab x)\n> x : a\n> Bool\n"})}),"\n",(0,t.jsx)(a.p,{children:"Checks if the given value is a table."}),"\n",(0,t.jsx)(a.pre,{children:(0,t.jsx)(a.code,{className:"language-sire",children:"isTab #[]           == 1\nisTab #[x=3 y=4]    == 1\nisTab []            == 0\n"})}),"\n",(0,t.jsx)(a.h3,{id:"tabsearchcase",children:"tabSearchCase"}),"\n",(0,t.jsx)(a.pre,{children:(0,t.jsx)(a.code,{children:"(tabSearchCase key t d k)\n> key : a\n> t   : Tab a b\n> d   : c\n> k   : (Nat > b > c)\n> c\n"})}),"\n",(0,t.jsx)(a.p,{children:"Inline function that finds the index of a key within a table. Returns a continuation with the associated value."}),"\n",(0,t.jsx)(a.pre,{children:(0,t.jsx)(a.code,{className:"language-sire",children:"tabSearchCase 1 #[1=3 2=4] {nf} (ix v & [ix v])    == [0 3]\ntabSearchCase 2 #[1=3 2=4] {nf} (ix v & [ix v])    == [1 4]\ntabSearchCase 3 #[1=3 2=4] {nf} (ix v & [ix v])    == %nf\n"})}),"\n",(0,t.jsx)(a.h3,{id:"tablen",children:"tabLen"}),"\n",(0,t.jsx)(a.pre,{children:(0,t.jsx)(a.code,{children:"(tabLen t)\n> t : Tab a\n> Nat\n"})}),"\n",(0,t.jsx)(a.p,{children:"Returns the number of key-value pairs in a table."}),"\n",(0,t.jsx)(a.pre,{children:(0,t.jsx)(a.code,{className:"language-sire",children:"tabLen #[]           == 0\ntabLen #[x=0]        == 1\ntabLen #[x=0 y=1]    == 2\n"})}),"\n",(0,t.jsx)(a.h3,{id:"tabidx",children:"tabIdx"}),"\n",(0,t.jsx)(a.pre,{children:(0,t.jsx)(a.code,{children:"(tabIdx key t)\n> key : a\n> t   : Tab a\n> b\n"})}),"\n",(0,t.jsx)(a.p,{children:"Retrieves the value associated with a given key in a table."}),"\n",(0,t.jsx)(a.pre,{children:(0,t.jsx)(a.code,{className:"language-sire",children:"tabIdx 0 #[0=8]             == 8\ntabIdx %aa #(bb=8, aa=9)    == 9\ntabIdx 3 #[1=4 2=5]         == 0\n"})}),"\n",(0,t.jsx)(a.h3,{id:"tabkeysset",children:"tabKeysSet"}),"\n",(0,t.jsx)(a.pre,{children:(0,t.jsx)(a.code,{children:"(tabKeysSet t)\n> t : Tab a\n> Set a\n"})}),"\n",(0,t.jsx)(a.p,{children:"Returns the set of keys in a table."}),"\n",(0,t.jsx)(a.pre,{children:(0,t.jsx)(a.code,{className:"language-sire",children:"tabKeysSet #[1=3 2=4]    == %[1 2]\ntabKeysSet #[]           == %[]\ntabKeysSet #[a=1 b=2]    == %[a b]\n"})}),"\n",(0,t.jsx)(a.h3,{id:"tabkeysrow",children:"tabKeysRow"}),"\n",(0,t.jsx)(a.pre,{children:(0,t.jsx)(a.code,{children:"(tabKeysRow t)\n> t : Tab a\n> Row a\n"})}),"\n",(0,t.jsx)(a.p,{children:"Returns the row of keys in a table."}),"\n",(0,t.jsx)(a.pre,{children:(0,t.jsx)(a.code,{className:"language-sire",children:"tabKeysRow #[3=3 4=4]    == [3 4]\ntabKeysRow #[]           == []\ntabKeysRow #[a=1 b=2]    == [%a %b]\n"})}),"\n",(0,t.jsx)(a.h3,{id:"tabkeyslist",children:"tabKeysList"}),"\n",(0,t.jsx)(a.pre,{children:(0,t.jsx)(a.code,{children:"(tabKeysList t)\n> t : Tab a\n> List a\n"})}),"\n",(0,t.jsx)(a.p,{children:"Returns the list of keys in a table."}),"\n",(0,t.jsx)(a.pre,{children:(0,t.jsx)(a.code,{className:"language-sire",children:"tabKeysList #[3=3 4=4]    == [3 [4 0]]\ntabKeysList #[]           == 0\ntabKeysList #[a=1 b=2]    == [%a [%b 0]]\n"})}),"\n",(0,t.jsx)(a.h3,{id:"tabhas",children:"tabHas"}),"\n",(0,t.jsx)(a.pre,{children:(0,t.jsx)(a.code,{children:"(tabHas key t)\n> key : a\n> t   : Tab a\n> Bool\n"})}),"\n",(0,t.jsx)(a.p,{children:"Checks if a key exists in a table."}),"\n",(0,t.jsx)(a.pre,{children:(0,t.jsx)(a.code,{className:"language-sire",children:"tabHas %aa #(bb=8, aa=9)    == 1\ntabHas %cc #(bb=8, aa=9)    == 0\ntabHas 1 #[1=4 2=5]         == 1\n"})}),"\n",(0,t.jsx)(a.h3,{id:"tabget",children:"tabGet"}),"\n",(0,t.jsx)(a.pre,{children:(0,t.jsx)(a.code,{children:"(tabGet t key)\n> t   : Tab a\n> key : a\n> b\n"})}),"\n",(0,t.jsx)(a.p,{children:"Retrieves the value associated with a given key in a table."}),"\n",(0,t.jsx)(a.pre,{children:(0,t.jsx)(a.code,{className:"language-sire",children:"tabGet #[1=4 2=5] 1    == 4\ntabGet #[1=4 2=5] 2    == 5\ntabGet #[1=4 2=5] 3    == 0\n"})}),"\n",(0,t.jsx)(a.h3,{id:"tabvalsrow",children:"tabValsRow"}),"\n",(0,t.jsx)(a.pre,{children:(0,t.jsx)(a.code,{children:"(tabValsRow t)\n> t : Tab a\n> Row b\n"})}),"\n",(0,t.jsx)(a.p,{children:"Returns the row of values in a table."}),"\n",(0,t.jsx)(a.pre,{children:(0,t.jsx)(a.code,{className:"language-sire",children:"tabValsRow #[3=3 4=4]    == [3 4]\ntabValsRow #[]           == []\ntabValsRow #[a=1 b=2]    == [1 2]\n"})}),"\n",(0,t.jsx)(a.h3,{id:"tabvalslist",children:"tabValsList"}),"\n",(0,t.jsx)(a.pre,{children:(0,t.jsx)(a.code,{children:"(tabValsList t)\n> t : Tab a\n> List b\n"})}),"\n",(0,t.jsx)(a.p,{children:"Returns the list of values in a table."}),"\n",(0,t.jsx)(a.pre,{children:(0,t.jsx)(a.code,{className:"language-sire",children:"tabValsList #[3=3 4=4]    == [3 [4 0]]\ntabValsList #[]           == 0\ntabValsList #[a=1 b=2]    == [1 [2 0]]\n"})}),"\n",(0,t.jsx)(a.h3,{id:"tabswitch",children:"tabSwitch"}),"\n",(0,t.jsx)(a.pre,{children:(0,t.jsx)(a.code,{children:"(tabSwitch key d t)\n> key : a\n> d   : b\n> t   : Tab b\n> b\n"})}),"\n",(0,t.jsx)(a.p,{children:"Looks up a key in a table, returning a default value if not found."}),"\n",(0,t.jsx)(a.pre,{children:(0,t.jsx)(a.code,{className:"language-sire",children:"tabSwitch 1 {not found} #[1=3 2=4]    == 3\ntabSwitch 2 {not found} #[1=3 2=4]    == 4\ntabSwitch 3 {not found} #[1=3 2=4]    == 0\n"})}),"\n",(0,t.jsx)(a.h3,{id:"tabfrompairs",children:"tabFromPairs"}),"\n",(0,t.jsx)(a.pre,{children:(0,t.jsx)(a.code,{children:"(tabFromPairs xs)\n> xs : Row (a, b)\n> Tab a\n"})}),"\n",(0,t.jsx)(a.p,{children:"Creates a table from a row of key-value pairs."}),"\n",(0,t.jsx)(a.pre,{children:(0,t.jsx)(a.code,{className:"language-sire",children:"tabFromPairs [[3 8] [5 9]]           == [3=8 5=9]\ntabFromPairs [[5 9] [3 8]]           == [3=8 5=9]\ntabFromPairs [[3 7] [3 8] [5 9]]     == [3=8 5=9]\n"})}),"\n",(0,t.jsx)(a.h3,{id:"tabfromascpairs",children:"tabFromAscPairs"}),"\n",(0,t.jsx)(a.pre,{children:(0,t.jsx)(a.code,{children:"(tabFromAscPairs xs)\n> xs : Row (a, b)\n> Tab a\n"})}),"\n",(0,t.jsx)(a.p,{children:"Creates a table from an ascending row of key-value pairs."}),"\n",(0,t.jsx)(a.pre,{children:(0,t.jsx)(a.code,{className:"language-sire",children:"tabFromAscPairs [[1 4] [2 5] [3 6]]    == [1=4 2=5 3=6]\ntabFromAscPairs []                     == []\ntabFromAscPairs [[a 1] [b 2]]          == [a=1 b=2]\n"})}),"\n",(0,t.jsx)(a.h3,{id:"tabtopairs",children:"tabToPairs"}),"\n",(0,t.jsx)(a.pre,{children:(0,t.jsx)(a.code,{children:"(tabToPairs t)\n> t : Tab a\n> Row (a, b)\n"})}),"\n",(0,t.jsx)(a.p,{children:"Converts a table to a row of key-value pairs."}),"\n",(0,t.jsx)(a.pre,{children:(0,t.jsx)(a.code,{className:"language-sire",children:"tabToPairs #[1=4 2=5 3=6]    == [[1 4] [2 5] [3 6]]\ntabToPairs #[]               == []\ntabToPairs #[a=1 b=2]        == [[a 1] [b 2]]\n"})}),"\n",(0,t.jsx)(a.h3,{id:"tabtopairlist",children:"tabToPairList"}),"\n",(0,t.jsx)(a.pre,{children:(0,t.jsx)(a.code,{children:"(tabToPairList t)\n> t : Tab a\n> List (a, b)\n"})}),"\n",(0,t.jsx)(a.p,{children:"Converts a table to a list of key-value pairs."}),"\n",(0,t.jsx)(a.pre,{children:(0,t.jsx)(a.code,{className:"language-sire",children:"tabToPairList #[3=8 5=9]    == [[3 8] [[5 9] 0]]\ntabToPairList #[]           == 0\ntabToPairList #[a=1]        == [[%a 1] 0]\n"})}),"\n",(0,t.jsx)(a.h3,{id:"tabtolist",children:"tabToList"}),"\n",(0,t.jsx)(a.pre,{children:(0,t.jsx)(a.code,{children:"(tabToList t)\n> t : Tab a\n> List (a, b)\n"})}),"\n",(0,t.jsx)(a.p,{children:"Converts a table to a list of key-value pairs."}),"\n",(0,t.jsx)(a.pre,{children:(0,t.jsx)(a.code,{className:"language-sire",children:"tabToList #[3=8 5=9]    == [[3 8] [5 9] 0]\ntabToList #[]           == 0\ntabToList #[a=1 b=2]    == [[%a 1] [%b 2] 0]\n"})}),"\n",(0,t.jsx)(a.h3,{id:"tabput",children:"tabPut"}),"\n",(0,t.jsx)(a.pre,{children:(0,t.jsx)(a.code,{children:"(tabPut t key val)\n> t   : Tab a\n> key : a\n> val : b\n> Tab a\n"})}),"\n",(0,t.jsx)(a.p,{children:"Inserts or updates a key-value pair in a table."}),"\n",(0,t.jsx)(a.pre,{children:(0,t.jsx)(a.code,{className:"language-sire",children:"tabPut #[1=3 2=4] 1 5    == [1=5 2=4]\ntabPut #[1=3 2=4] 3 5    == [1=3 2=4 3=5]\ntabPut #[] 1 5           == [1=5]\n"})}),"\n",(0,t.jsx)(a.h3,{id:"tabfrompairslist",children:"tabFromPairsList"}),"\n",(0,t.jsx)(a.pre,{children:(0,t.jsx)(a.code,{children:"(tabFromPairsList xs)\n> xs : List (a, b)\n> Tab a\n"})}),"\n",(0,t.jsx)(a.p,{children:"Creates a table from a list of key-value pairs."}),"\n",(0,t.jsx)(a.pre,{children:(0,t.jsx)(a.code,{className:"language-sire",children:"tabFromPairsList ~[[3 8] [5 9]]      == [3=8 5=9]\ntabFromPairsList 0                   == []\ntabFromPairsList ~[[%a 1] [%b 2]]    == [a=1 b=2]\n"})}),"\n",(0,t.jsx)(a.h3,{id:"tabins",children:"tabIns"}),"\n",(0,t.jsx)(a.pre,{children:(0,t.jsx)(a.code,{children:"(tabIns key val t)\n> key : a\n> val : b\n> t   : Tab a\n> Tab a\n"})}),"\n",(0,t.jsx)(a.p,{children:"Inserts a key-value pair into a table."}),"\n",(0,t.jsx)(a.pre,{children:(0,t.jsx)(a.code,{className:"language-sire",children:"tabIns 3 3 #[3=4]    == [3=3]\ntabIns 4 4 #[3=4]    == [3=4 4=4]\ntabIns 0 0 #[]       == [0=0]\n"})}),"\n",(0,t.jsx)(a.h3,{id:"tabisempty",children:"tabIsEmpty"}),"\n",(0,t.jsx)(a.pre,{children:(0,t.jsx)(a.code,{children:"(tabIsEmpty t)\n> t : Tab a\n> Bool\n"})}),"\n",(0,t.jsx)(a.p,{children:"Checks if a table is empty."}),"\n",(0,t.jsx)(a.pre,{children:(0,t.jsx)(a.code,{className:"language-sire",children:"tabIsEmpty #[]           == 1\ntabIsEmpty #[1=2]        == 0\ntabIsEmpty #[a=1 b=2]    == 0\n"})}),"\n",(0,t.jsx)(a.h3,{id:"tabdel",children:"tabDel"}),"\n",(0,t.jsx)(a.pre,{children:(0,t.jsx)(a.code,{children:"(tabDel key t)\n> key : a\n> t   : Tab a\n> Tab a\n"})}),"\n",(0,t.jsx)(a.p,{children:"Deletes a key-value pair from a table."}),"\n",(0,t.jsx)(a.pre,{children:(0,t.jsx)(a.code,{className:"language-sire",children:"tabDel 1 #[1=3 2=4]     == [2=4]\ntabDel 3 #[1=3 2=4]     == [1=3 2=4]\ntabDel %a #[a=1 b=2]    == [b=2]\n"})}),"\n",(0,t.jsx)(a.h3,{id:"tabpop",children:"tabPop"}),"\n",(0,t.jsx)(a.pre,{children:(0,t.jsx)(a.code,{children:"(tabPop t)\n> t : Tab a\n> (a, b, Tab a)\n"})}),"\n",(0,t.jsx)(a.p,{children:"Removes and returns the first key-value pair from a table along with the remaining table."}),"\n",(0,t.jsx)(a.pre,{children:(0,t.jsx)(a.code,{className:"language-sire",children:"tabPop #[1=3 2=4]        == [1 3 [2=4]]\ntabPop #[a=1]            == [%a 1 #[]]\ntabPop #[a=1 b=2 c=3]    == [%a 1 [b=2 c=3]]\n"})}),"\n",(0,t.jsx)(a.h3,{id:"tabsplitat",children:"tabSplitAt"}),"\n",(0,t.jsx)(a.pre,{children:(0,t.jsx)(a.code,{children:"(tabSplitAt i t)\n> i : Nat\n> t : Tab a\n> (Tab a, Tab a)\n"})}),"\n",(0,t.jsx)(a.p,{children:"Splits a table into two tables at a given index."}),"\n",(0,t.jsx)(a.pre,{children:(0,t.jsx)(a.code,{className:"language-sire",children:"tabSplitAt 1 #[1=3 2=4 3=5]    == [[1=3] [2=4 3=5]]\ntabSplitAt 0 #[1=3 2=4]        == [#[] [1=3 2=4]]\ntabSplitAt 2 #[a=1 b=2 c=3]    == [[a=1 b=2] [c=3]]\n"})}),"\n",(0,t.jsx)(a.h3,{id:"tabsplitlt",children:"tabSplitLT"}),"\n",(0,t.jsx)(a.pre,{children:(0,t.jsx)(a.code,{children:"(tabSplitLT k t)\n> k : a\n> t : Tab a\n> (Tab a, Tab a)\n"})}),"\n",(0,t.jsx)(a.p,{children:"Splits a table into two tables based on a key."}),"\n",(0,t.jsx)(a.pre,{children:(0,t.jsx)(a.code,{className:"language-sire",children:"tabSplitLT 2 #[1=3 2=4 3=5]     == [[1=3] [2=4 3=5]]\ntabSplitLT 0 #[1=3 2=4]         == [#[] [1=3 2=4]]\ntabSplitLT %b #[a=1 b=2 c=3]    == [[a=1] [b=2 c=3]]\n"})}),"\n",(0,t.jsx)(a.h3,{id:"tabalter",children:"tabAlter"}),"\n",(0,t.jsx)(a.pre,{children:(0,t.jsx)(a.code,{children:"(tabAlter f key t)\n> f   : (Maybe a > Maybe b)\n> key : a\n> t   : Tab a\n> Tab a\n"})}),"\n",(0,t.jsx)(a.p,{children:"Applies a function to the value associated with a key, potentially inserting or deleting the key-value pair."}),"\n",(0,t.jsx)(a.pre,{children:(0,t.jsx)(a.code,{className:"language-sire",children:"tabAlter (v & SOME (inc v)) 1 #[1=3 2=4]    == [1=1 2=4]\ntabAlter (v & NONE) 1 #[1=3 2=4]            == [2=4]\ntabAlter (v & SOME 5) 3 #[1=3 2=4]          == [1=3 2=4 3=5]\n"})}),"\n",(0,t.jsx)(a.h3,{id:"tabmapwithkey",children:"tabMapWithKey"}),"\n",(0,t.jsx)(a.pre,{children:(0,t.jsx)(a.code,{children:"(tabMapWithKey f t)\n> f : (a > a > a)\n> t : Tab a\n> Tab a\n"})}),"\n",(0,t.jsx)(a.p,{children:"Applies a function to each key-value pair in a table."}),"\n",(0,t.jsx)(a.pre,{children:(0,t.jsx)(a.code,{className:"language-sire",children:"tabMapWithKey (k v & add k v) #[1=3 2=4]    == [1=4 2=6]\ntabMapWithKey (k v & [k v]) #[a=1 b=2]      == [a=[%a 1] b=[%b 2]]\ntabMapWithKey (k v & inc v) #[]             == #[]\n"})}),"\n",(0,t.jsx)(a.h3,{id:"tabmap",children:"tabMap"}),"\n",(0,t.jsx)(a.pre,{children:(0,t.jsx)(a.code,{children:"(tabMap f t)\n> f : (a > a)\n> t : Tab a\n> Tab a\n"})}),"\n",(0,t.jsx)(a.p,{children:"Applies a function to each value in a table."}),"\n",(0,t.jsx)(a.pre,{children:(0,t.jsx)(a.code,{className:"language-sire",children:"tabMap inc #[1=3 2=4]       == [1=4 2=5]\ntabMap (mul 2) #[a=1 b=2]   == [a=2 b=4]\ntabMap id #[]               == #[]\n"})}),"\n",(0,t.jsx)(a.h3,{id:"tabunionwith",children:"tabUnionWith"}),"\n",(0,t.jsx)(a.pre,{children:(0,t.jsx)(a.code,{children:"(tabUnionWith f t1 t2)\n> f  : (a > a > a)\n> t1 : Tab a\n> t2 : Tab a\n> Tab a\n"})}),"\n",(0,t.jsx)(a.p,{children:"Merges two tables, using a function to resolve conflicts."}),"\n",(0,t.jsx)(a.pre,{children:(0,t.jsx)(a.code,{className:"language-sire",children:"tabUnionWith add #[1=1 2=2] #[2=20 3=30]                                        == [1=1 2=22 3=30]\ntabUnionWith const #[a=1 b=2] #[b=20 c=30]                                      == [a=1 b=2 c=30]\ntabUnionWith (x y & LEFT [x y]) #[1=(RIGHT 10)] #[1=(RIGHT 11) 2=(RIGHT 12)]    == [1=(LEFT [10 11]) 2=(RIGHT 12)]\n"})}),"\n",(0,t.jsx)(a.h3,{id:"tabunion",children:"tabUnion"}),"\n",(0,t.jsx)(a.pre,{children:(0,t.jsx)(a.code,{children:"(tabUnion t1 t2)\n> t1 : Tab a\n> t2 : Tab a\n> Tab a\n"})}),"\n",(0,t.jsx)(a.p,{children:"Merges two tables, with left-biased conflict resolution."}),"\n",(0,t.jsx)(a.pre,{children:(0,t.jsx)(a.code,{className:"language-sire",children:"tabUnion #[1=1 2=2] #[2=20 3=30]    == [1=1 2=2 3=30]\ntabUnion #[a=1 b=2] #[b=20 c=30]    == [a=1 b=2 c=30]\ntabUnion #[] #[1=10 2=20]           == [1=10 2=20]\n"})}),"\n",(0,t.jsx)(a.h3,{id:"tabweld",children:"tabWeld"}),"\n",(0,t.jsx)(a.pre,{children:(0,t.jsx)(a.code,{children:"(tabWeld t1 t2)\n> t1 : Tab a\n> t2 : Tab a\n> Tab a\n"})}),"\n",(0,t.jsx)(a.p,{children:"Alias for tabUnion. Merges two tables, with left-biased conflict resolution."}),"\n",(0,t.jsx)(a.pre,{children:(0,t.jsx)(a.code,{className:"language-sire",children:"tabWeld #[1=1 2=2] #[2=20 3=30]    == [1=1 2=2 3=30]\ntabWeld #[a=1 b=2] #[b=20 c=30]    == [a=1 b=2 c=30]\ntabWeld #[] #[1=10 2=20]           == [1=10 2=20]\n"})}),"\n",(0,t.jsx)(a.h3,{id:"tabcatrow",children:"tabCatRow"}),"\n",(0,t.jsx)(a.pre,{children:(0,t.jsx)(a.code,{children:"(tabCatRow xs)\n> xs : Row (Tab a)\n> Tab a\n"})}),"\n",(0,t.jsx)(a.p,{children:"Merges a row of tables into a single table, with left-biased conflict resolution."}),"\n",(0,t.jsx)(a.pre,{children:(0,t.jsx)(a.code,{className:"language-sire",children:"tabCatRow [#[1=1] #[2=2] #[3=3]]           == [1=1 2=2 3=3]\ntabCatRow [#[a=1 b=2] #[b=20 c=30] #[]]    == [a=1 b=2 c=30]\ntabCatRow []                               == #[]\n"})}),"\n",(0,t.jsx)(a.h3,{id:"tablookup",children:"tabLookup"}),"\n",(0,t.jsx)(a.pre,{children:(0,t.jsx)(a.code,{children:"(tabLookup key t)\n> key : a\n> t   : Tab a\n> Maybe a\n"})}),"\n",(0,t.jsx)(a.p,{children:"Looks up a key in a table, returning a Maybe value."}),"\n",(0,t.jsx)(a.pre,{children:(0,t.jsx)(a.code,{className:"language-sire",children:"tabLookup 1 #[1=3 2=4]    == (0 3) ; SOME\ntabLookup 2 #[1=3 2=4]    == (0 4) ; SOME\ntabLookup 3 #[1=3 2=4]    == 0 ; NONE\n"})}),"\n",(0,t.jsx)(a.h3,{id:"tabminkey",children:"tabMinKey"}),"\n",(0,t.jsx)(a.pre,{children:(0,t.jsx)(a.code,{children:"(tabMinKey t)\n> t : Tab a\n> a\n"})}),"\n",(0,t.jsx)(a.p,{children:"Returns the smallest key in a table."}),"\n",(0,t.jsx)(a.pre,{children:(0,t.jsx)(a.code,{className:"language-sire",children:"tabMinKey #[3=30 1=10 2=20]    == 1\ntabMinKey #[a=1 b=2 c=3]       == %a\ntabMinKey #[z=26]              == %z\n"})}),"\n",(0,t.jsx)(a.h3,{id:"tabfoldlwithkey",children:"tabFoldlWithKey"}),"\n",(0,t.jsx)(a.pre,{children:(0,t.jsx)(a.code,{children:"(tabFoldlWithKey f acc t)\n> f   : (a > b)\n> acc : b\n> t   : Tab a\n> b\n"})}),"\n",(0,t.jsx)(a.p,{children:"Folds over a table, applying a function to each key-value pair and an accumulator."}),"\n",(0,t.jsx)(a.pre,{children:(0,t.jsx)(a.code,{className:"language-sire",children:"tabFoldlWithKey (acc k v & add acc (mul k v)) 0 #[1=3 2=4]    == 11\ntabFoldlWithKey (acc k v & weld acc [k v]) [] #[a=1 b=2]      == [%a 1 %b 2]\ntabFoldlWithKey (acc k v & inc acc) 0 #[]                     == 0\n"})}),"\n",(0,t.jsx)(a.h3,{id:"tabelemidx",children:"tabElemIdx"}),"\n",(0,t.jsx)(a.pre,{children:(0,t.jsx)(a.code,{children:"(tabElemIdx i t)\n> i : Nat\n> t : Tab a\n> Row a\n"})}),"\n",(0,t.jsx)(a.p,{children:"Returns the index of a key-value pair in a table, treating it as an array."}),"\n",(0,t.jsx)(a.pre,{children:(0,t.jsx)(a.code,{className:"language-sire",children:"tabElemIdx 0 #[a=1 b=2 c=3]    == [%a 1]\ntabElemIdx 1 #[a=1 b=2 c=3]    == [%b 2]\ntabElemIdx 3 #[a=1 b=2 c=3]    == 0\n"})}),"\n",(0,t.jsx)(a.h3,{id:"emptytab",children:"emptyTab"}),"\n",(0,t.jsx)(a.pre,{children:(0,t.jsx)(a.code,{children:"emptyTab\n> Tab a\n"})}),"\n",(0,t.jsx)(a.p,{children:"An empty table constant."}),"\n",(0,t.jsx)(a.pre,{children:(0,t.jsx)(a.code,{className:"language-sire",children:"emptyTab                    == #[]\ntabIsEmpty emptyTab         == 1\ntabUnion emptyTab #[1=2]    == [1=2]\n"})}),"\n",(0,t.jsx)(a.h3,{id:"tabinswith",children:"tabInsWith"}),"\n",(0,t.jsx)(a.pre,{children:(0,t.jsx)(a.code,{children:"(tabInsWith f key val t)\n> f   : (a > a > b)\n> key : a\n> val : b\n> t   : Tab a\n> Tab a\n"})}),"\n",(0,t.jsx)(a.p,{children:"Inserts a key-value pair into a table, using a function to combine values if the key already exists."}),"\n",(0,t.jsx)(a.pre,{children:(0,t.jsx)(a.code,{className:"language-sire",children:"tabInsWith add 1 6 #[1=3 2=4]          == [1=9 2=4]\ntabInsWith const 1 6 #[1=3 2=4]        == [1=6 2=4]\ntabInsWith (x y & [x y]) 3 6 #[1=3]    == [1=3 3=6]\n"})}),"\n",(0,t.jsx)(a.h3,{id:"tabfilterwithkey",children:"tabFilterWithKey"}),"\n",(0,t.jsx)(a.pre,{children:(0,t.jsx)(a.code,{children:"(tabFilterWithKey f t)\n> f : (a > b > Bool)\n> t : Tab a\n> Tab a\n"})}),"\n",(0,t.jsx)(a.p,{children:"Filters a table based on a predicate function applied to each key-value pair."}),"\n",(0,t.jsx)(a.pre,{children:(0,t.jsx)(a.code,{className:"language-sire",children:"tabFilterWithKey (k v & even k) #[1=1 2=2 3=3 4=4]     == [2=2 4=4]\ntabFilterWithKey (k v & eql k v) #[a=1 b=2 c=3]        == #[]\ntabFilterWithKey (k v & gth v 2) #[a=1 b=2 c=3 d=4]    == [c=3 d=4]\n"})})]})}function h(e={}){const{wrapper:a}={...(0,i.R)(),...e.components};return a?(0,t.jsx)(a,{...e,children:(0,t.jsx)(c,{...e})}):c(e)}},8453:(e,a,n)=>{n.d(a,{R:()=>l,x:()=>r});var t=n(6540);const i={},s=t.createContext(i);function l(e){const a=t.useContext(s);return t.useMemo((function(){return"function"==typeof e?e(a):{...a,...e}}),[a,e])}function r(e){let a;return a=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:l(e.components),t.createElement(s.Provider,{value:a},e.children)}}}]);